[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HW // WLM 2023",
    "section": "",
    "text": "Вступление\nВ этой книжке собраны домашки с курса WLM 2023.\nРазборы домашек опубликованы здесь.\nЗаписи консультаций опубликованы здесь.",
    "crumbs": [
      "Вступление"
    ]
  },
  {
    "objectID": "hw1.html",
    "href": "hw1.html",
    "title": "HW1 // Введение в R. Типы данных. Векторы",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW1 // Введение в R. Типы данных. Векторы"
    ]
  },
  {
    "objectID": "hw1.html#hw1_main",
    "href": "hw1.html#hw1_main",
    "title": "HW1 // Введение в R. Типы данных. Векторы",
    "section": "",
    "text": "#1\n\n\nСгенерируйте распределение некоторой изучаемой переменной в генеральной совокупности из 350 000 объектов с помощью функции rnorm() с параметрами mean = 80 и sd = 21. Сохраните результат генерации в переменную pop.\n\n\n\nДля самопроверки скопируйте из консоли в поле ниже два первых значения получившегося вектора. Разделите значения запятой. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nИспользуя функцию rnorm() нужно сгенерировать вектор. Для этого ей нужно передать три аргумента: количество значений, которые нужно сгененировать, среднее (mean) и стандартное отклонение (sd).\nОбратите внимание на порядок аргументов: следовать они должны именно так, как перечислены в предыдущем пункте.\nСохраните результат генерации в переменной pop с помощью оператора присваивания &lt;-.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, выполнили ли вы строчку строчку с установкой зерна датчика случайных чисел перед генерацией вектора.\nПроверьте, разделили ли вы значения запятой.\nОкруглять значения не нужно.\n\n\n\n\n\n\n#2\n\n\nСгенерируйте случайную выборку из генеральной совокупности (pop) объемом 150 значений. Считайте, что все объекты генеральной совокупности равновероятно попадают в выборку. Сохраните результаты генерации в переменную first_banch.\n\n\n\nДля самопроверки в поле ниже введите сумму по получившемуся вектору.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nИспользуя функцию sample() нужно сгенерировать вектор. Для этого её нужно передать два обязательных аргумента: вектор, из которого она будет выбирать числа, и количество значений, которые нужно сгенерировать.\nОбратите внимание на порядок аргументов: следовать они должны именно так, как перечислены в предыдущем пункте.\nСохраните результат генерации в переменной first_bach с помощью оператора присваивания &lt;-.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, выполнили ли вы строчку строчку с установкой зерна датчика случайных чисел перед генерацией вектора.\nОкруглять значения не нужно.\n\n\n\n\n\n\n#3\n\n\nУдалите из полученный выборки 5 наибольших и 5 наименьших значений — посчитаем их нехарактерными значениями (выбросами). Перезапишите вектор first_banch.\n\n\n\nДля самопроверки в поле ниже введите сумму по получившемуся после удаления значений вектору.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак осмыслить задание?\n\n\nНужно удалить 5 наибольших и 5 наименьших значений. Что нужно сделать с вектором, чтобы было проще его индексировать по индексам для решения задачи?\nКак должен выглядет вектор индексов?\n\nМожете создать вспомогательный вектор indices и использовать его для индексации вектора выборки.\n\nКак обозначить при индексации удаление выбраных элементов?\n\n\n\n\nПолезная функция\n\nsort()\n\n\n\nУдаляются почти все значения ((\n\nОператор : имеет более высокий приоритет по сравнению с арифметическими операторами. Соответственно, сначала выпоняется он, а затем арифметические операции.\n\n\n\nОтвет неверный\n\n\nПроверьте, выполнили ли вы строчку строчку с установкой зерна датчика случайных чисел перед генерацией вектора.\nПроверьте, сколько значений осталось в векторе после удаления выбросов.\nОкруглять значения не нужно.\n\n\n\n\n\n\n#4\n\n\nВаш коллега прислал вам вторую часть собранных данных. Выполните команду ниже, чтобы загрузить её в переменную second_banch.\n\nsecond_banch &lt;- read.csv(\"https://raw.githubusercontent.com/angelgardt/wlm2023/master/data/hw1-second_banch.csv\")$x\n\nОбъедините векторы first_banch и second_banch в один для дальнейшей работы. Назовите получившийся вектор obs.\n\n\n\nДля самопроверки в поле ниже введите длину получившегося вектора.\n\n\n\n\n\n\n\n\n\n#5\n\n\nИсследуйте получившийся вектор:\n\nкакой тип его данных?\nесли ли в нем пропущенные значения?\nесли есть, сколько их?\n\n\n\n\nДля самопроверки в поле ниже введите через запятую обнаруженный тип данных и количество пропущенных значений. Название типа данных введите без кавычек. Если пропущенных значений нет, укажите 0. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак проверить тип данных?\n\nМожно использовать функции семейста is.*() или функции class() и typeof().\n\n\n\nКак посчитать количество пропусков?\n\nДля этого нужно сначала проверить, является ли каждое значение вектора пропуском (NA), а затем посчитать сумму от результатов проверки.\n\n\n\nОтвет неверный\n\n\nПроверьте, не опечатались ли вы в названии типа данных.\nПроверьте, разделили ли вы тип данных и количество пропусков запятой.\n\n\n\n\n\n\n#6\n\n\nПриведите вектор obs в порядок, если необходимо:\n\nудалите пропущенные значения\nскорректируйте тип данных\n\nПерезапишите объект obs.\n\n\n\nДля самопроверки введите количество элементов, оставшихся в векторе после того, как вы привели его в порядок.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nПредположите, откуда могла возникнуть сложившаяся проблема.\nВыполните приведение типа данных к нужному.\nПроверьте, решила ли проблема.\nУдалите пропущенные значения через индексацию вектора\nСохраните полученный результат в переменную obs.\n\n\n\n\nКак удалить пропуски?\n\n\nПроверьте, является ли каждое значение вектора пропуском.\nПомните, что x == NA ведет себя не так, как мы бы хотели.\nИспользуйте вектор, полученный при проверке, для индексации.\nОбратите внимание, что проверка на пропуск возвращает TRUE, если значение является пропуском. Нам же нужно отобрать те, которые не являются ими.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что в векторе действительно не осталось пропущенных значений.\n\n\n\n\n\n\n#7\n\n\nНа полученном векторе obs рассчитайте:\n\nминимум\nмаксимум\nсреднее\nмедиану\n\n\n\n\nДля самопроверки введите через запятую полученные значения в порядке, указанном в задании. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nОтвет неверный\n\nПроверьте последовательность вводимых значений.\n\n\n\n\n\n#8\n\n\n\nОтсортируйте значения вектора по возрастанию\nНайдите медиану первой (меньшей) половины значений\nНайдите медиану второй (большей) половины значений\n\nТак как количество элементов нечетное, считайте, что срединное значение входит в обе половины.\n\n\n\nДля самопроверки введите в поле ниже через запятую значения, полученные в пунктах (b) и (c).\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nОтсортируйте вектор с помощью функции sort()\nС помощью индексов отберите первую (меньшую) половину значений\nПередайте получившийся вектор в качестве аргумента функции median()\nАналогично поступите со второй (большей) половиной\n\n\n\n\nКак отобрать половину значений?\n\n\nМожно задать индексы руками, вычислив, какое количество элементов составляет половину вектора.\nМожно использовать идею, что индекс середины вектора — это округленная половина его длины (round()`)\n\n\n\n\nОтвет неверный\n\n\n\nПроверьте, правильно ли вы определили индекс срединного элемента\nПроверьте, что при расчете медиан вы включили срединный элемент в обе половины вектора\nПроверьте, что вы разделили значения запятой\n\n\n\n\n\n#9\n\n\nВыборка нашего исследования включала в себя респондентов из пяти групп. Сгенерируйте группирующий вектор такой же длины, как и наша переменная, случайным образом из значений gr1, gr2, gr3, gr4 и gr5. Сохраните результат генерации в переменную condition.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nС помощью функции sample() сгенерируйте вектор необходимой длины из обозначенных в задании текстовых значений\nСохраните его в переменную condition с помощью оператора присваивания &lt;-\n\n\n\n\nФункция падает с ошибкой\n\nКоличество допустимых значений (групп) меньше, чем неободимое количество элементов генерируемого вектора. Изучите аргумент replace функции sample().\n\n\n\n\n\n#10\n\n\nПроверьте, насколько группы в исследовании получились сбалансированы.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак проверить сбалансированность групп?\n\n\nЧтобы проверить сбалансированность групп, надо посчитать, сколько вошло наблюдений в каждую группу.\nЭто можно сделать, построив таблицу частот.\n\n\n\n\nКак построить таблицу частот?\n\nС помощью функции table()",
    "crumbs": [
      "HW1 // Введение в R. Типы данных. Векторы"
    ]
  },
  {
    "objectID": "hw1.html#hw1_add",
    "href": "hw1.html#hw1_add",
    "title": "HW1 // Введение в R. Типы данных. Векторы",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n#1\n\n\nСейчас у нас лежат отдельно наблюдения (obs) и отдельно группы респондентов (condition). Хотелось бы как-то их связать друг с другом. Хоть мы и владеем из всех структур данных пока только вектором, у нас есть способ осуществить желаемое. Это именованный вектор.\nЗадайте элементам вектора obs имена, которыми будут элементы вектора condition. Таким образом, мы будем знать, к какой группе относиться каждое наблюдение.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nВ векторе condition содержать группы респондентов, а в векторе obs — наблюдения.\nКаждое наблюдение относится к какой-либо группе.\nЕсли мы используем значения вектора condition как имена для вектора obs мы объединим данные из обоих векторов в одной структуре.\nНеобходимо присвоить элементам obs имена из значений вектора condition.\n\n\n\n\nКак задать имена элементам вектора?\n\nИ для вывода, и для задания имён используется функция names().\n\n\n\n\n\n#2\n\n\nВ задании 7 мы рассчитали несколько значений, описывающих изучаемый нами вектор. Теперь, когда мы познакомились с именованным вектором, мы можем объединить все рассчитанные значения в один вектор и подписать их, чтобы не забыть, что есть что.\nВозьмите код из задания 7 и дополните его так, чтобы результаты вычислений собирались в один именованный вектор. Необходимый результат представлен ниже.\n\n\n      min       max      mean    median \n 42.42735 124.26487  79.84587  79.95837 \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\nНеобходимо объединить четыре «функции» (их результаты) в вектор и при создании вектора задать имена его элементам.\n\n\n\nКак задать имена элементам вектора?\n\nСоздавая вектор с помощью функции c() мы можем указать имя для каждого элемента:\n\nc(name1 = \"x1\", name2 = \"x2\", ...)\n\n\n\n\n\n\n#3\n\n\nВозьмите получившийся вектор obs с наблюдениями и группами и разделите выборку на две равные подвыборки случайным образом. Сохраните результаты в переменные sam1 и sam2.\n\n\n\n\n\n\n\n\n\n\n\n\n\n#4\n\n\nПроверьте сбалансированность групп по количеству наблюдений в получившихся подвыборках.\n\n\n\n\n\n\n\n\n\n\n\n\n\n#5\n\n\nСоздайте вектор из первых десяти элементов последовательности\n\\[\nx(n) = \\frac{n^n}{\\sqrt[n]{n}}\n\\]\n\n\n\nДля самопроверки введите последний элемент получившегося вектора. Используйте научную нотацию числа (формата 1.23e+04).",
    "crumbs": [
      "HW1 // Введение в R. Типы данных. Векторы"
    ]
  },
  {
    "objectID": "hw2.html",
    "href": "hw2.html",
    "title": "HW2 // Матрицы и списки. Функции",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW2 // Матрицы и списки. Функции"
    ]
  },
  {
    "objectID": "hw2.html#hw2_main",
    "href": "hw2.html#hw2_main",
    "title": "HW2 // Матрицы и списки. Функции",
    "section": "",
    "text": "#1\n\n\nСгенерируйте две матрицы, которые будут содержать по 50 выборок, объемом по 70 наблюдений, из генеральной совокупности, в которой распределение некоторого признака подчиняется нормальному распределению (rnorm()) с параметрами mean = 20.5 и sd = 3.48. Каждой выборке в матрице должен соответствовать один столбец. Сохраните результаты генерации в перемененые sim1 и sim2.\n\n\n\n\n\n\nОслабим контроль случайности\n\n\n\nТак как задание подразумевает генерацию случайных чисел, для воспроизводимых результатов нужно установить зерно датчика случайных чисел. Однако нам нужно сгенерировать две разные матрицы — нет смысла работать с двумя одинаковыми. Если же мы установим одинаковое зерно датчика перед обоими строками с генерацией матриц, то получим как раз две одинаковые матрицы. Поэтому в данном задании set.seed нужно выполнить один раз перед двумя последующими генерациями. Шаблон кода будет выглядеть так\n\nset.seed(420)\nsim1 &lt;- ...\nsim2 &lt;- ...\n\nАвтопроверка настроена на результаты, получаемые при значении зерна датчика случайных чисел set.seed(420).\n\n\n\n\n\nВ качестве самопроверки введите значения из первой строки первого солбца первой и второй матриц (иммено в таком порядке). Значения округлите до сотых по арифметическим правилам и разделите запятой. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nИспользуя функцию rnorm() нужно сгенерировать вектор, длиной равной количеству выборок, умноженному на количество наблюдений в одной выборке.\nЗатем «сложить» вектор в матрицу, размером число наблюдений в выборке × число выборок.\nСохранить результат генерации в переменную sim1.\nПовторить шаги генерации и сохранить результат в переменную sim2.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, выполнили ли вы строчку строчку с установкой зерна датчика случайных чисел перед генерацией вектора.\nПроверьте, разделили ли вы значения запятой.\nПроверьте округление — округлить необходимо по арифметическим правилам: \\(9.434 \\rightarrow 9.43, \\, 9.435 \\rightarrow 9.44\\).\n\n\n\n\n\n\n#2\n\n\nНапишите функцию mean_sd, которая будет вычислять среднее (mean()) и стандартное отклонение (sd()) по всем выборкам (столбцам) одной матрицы.\nФункция должна принимать на вход матрицу произвольного размера и возвращать матрицу, в которой первой строкой будут средние по каждому столбцу матрицы, а второй — стандартные отклонения. Количество столбцов матрицы аутпута (результата работы функции) должно совпадать с количеством столбцов входной матрицы.\n\n\n\nДля проверки корректности работы функции выполните её на матрице\n\\[\n\\pmatrix{1 & 4 & 7 \\\\ 2 & 5 & 8 \\\\ 3 & 6 & 9}\n\\] В поле ответа введите сначала строку со средними, разделив их запятыми, затем точку с запятой, а затем строку со стандартными отклонениями, также разделив их запятыми. Проверка проигнорирует все пробелы, поэтому для удобства ввода можете их использовать.\nПривет формата ответа:\n1.2, 2.3, 3.4; 0.1, 0.2, 0.3.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nВ функции необходимо вызвать функцию apply() для расчета каждой из статистик — среднего и стандартного отклонения.\nРезультаты работы функций необходимо объединить в матрицу — можно воспользоваться matrix() или rbind().\nПри использовании matrix() необходимо указать число столбцов, которое равно числу столбцов входной матрицы.\n\n\n\n\nОтвет неверный\n\n\nПроверьте правильность создания или генерации тестовой матрицы.\nПроверьте, разделили ли вы значения строк запятыми.\nПроверьте, разделили ли вы строки матрицы точкой с запятой.\n\n\n\n\n\n\n#3\n\n\nПримените функцию, написанную в задании 2, к матрице sim1.\n\n\n\nДля самопроверки введи в поле ответа первые три средних, разделённые запятыми, далее точку с запятой и затем первые три стандартных отклонения, также разделенные запятыми. Значения округлите до сотых по арифметическим правилам. Проверка проигнорирует все пробелы, поэтому для удобства ввода можете их использовать.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nНеобходимо вызвать созданную функцию mean_sd() на ранее сгенерированной матрице sim1.\nДля округления можно использоваться функцию round(), где вторым аргументом указать 2.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, разделили ли вы значения строк запятыми.\nПроверьте, разделили ли вы строки матрицы точкой с запятой.\nПроверьте округление — округлить необходимо по арифметическим правилам: \\(9.434 \\rightarrow 9.43, \\, 9.435 \\rightarrow 9.44\\).\n\n\n\n\n\n\n#4\n\n\nВыполните t-тест на первых колонках матриц sim1 и sim2 и сохраните результат в переменную ttest_res.\nt-тест выполняется с помощью функции t.test(), в которую необходимо передать в качестве аргументов два вектора. Синтаксис выглядит так:\n\nt.test(vector1, vector2)\n\nПонимание статистики, стоящей за данной функцией, для выполнения задания не требуется.\n\n\n\nВ качестве ответа для самопроверки введите t-значение (statistics), полученное при выполнении теста, округленная до сотых по арифметическим правилам.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nВыделите первые колонки сгенерированных матриц sim1 и sim2\nПередайте их в функцию t.test()\nСохраните результат работы функции в переменную ttest\nВыведите содержимое переменной в консоль, чтобы получить значение для ввода в поле самопроверки.\n\n\n\nОтвет неверный\n\n\nПроверьте, что из матриц были выделены колонки.\nПроверьте, что были выделены имеено первые колонки.\nПроверьте, что в поле самопроверки вы вводите именно значение t-статистики.\nПроверьте округление — округлить необходимо по арифметическим правилам: \\(9.434 \\rightarrow 9.43, \\, 9.435 \\rightarrow 9.44\\).\n\n\n\n\n\n\n#5\n\n\nИзвлеките из результатов t-теста оценки средних по выборкам (estimate), значение статистики (statistic) и p-value (p.value).\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nИзучите структуру переменной ttest — это список.\nПроиндексируйте список с помощью имен его элементов.\nВыведите значения в консоль.\n\n\n\n\n\n\n#6\n\n\nОбъедините извлеченные значения в именнованый список. Названия элементов сохраните исходными — estimate, statistic и p.value соответственно.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nНеобходимо создать список, в который сохранить часть значений из переменной ttest.\nСписок должен состоять из трех элементов, которым необходимо присвоить при создании имена, указанные в задании.\n\n\n\n\n\n\n#7\n\n\nУ нас есть кирпичики для сбора новой функции.\nОсновываясь на предыдущих заданиях, напишите функцию, которая выполняет серию t-тестов на соответствующих выборках (столбцах матриц). Сохраните функцию в переменную stat_testing.\nФункция должна:\n\nпринимать на вход две матрицы\nвозвращать список, каждый элементов которого является результат одного t-теста\nкаждый результат t-теста также является списком и состоит из трех элементов — estimate, statistic и p.value (как в задании 6)\n\nПример синтаксиса функции и результата её работы на матрицах A и B:\n\\[\nA = \\pmatrix{1 & 4 & 7 \\\\ 2 & 5 & 8 \\\\ 3 & 6 & 9}, \\quad\nB = \\pmatrix{10 & 40 & 70 \\\\ 20 & 50 & 80 \\\\ 30 & 60 & 90}\n\\]\n\n\nstat_testing(A, B) # A and B both are matrices\n\n[[1]]\n[[1]]$estimate\nmean of x mean of y \n        2        20 \n\n[[1]]$statistic\n        t \n-3.102219 \n\n[[1]]$p.value\n[1] 0.0878746\n\n\n[[2]]\n[[2]]$estimate\nmean of x mean of y \n        5        50 \n\n[[2]]$statistic\n        t \n-7.755547 \n\n[[2]]$p.value\n[1] 0.0153293\n\n\n[[3]]\n[[3]]$estimate\nmean of x mean of y \n        8        80 \n\n[[3]]$statistic\n        t \n-12.40888 \n\n[[3]]$p.value\n[1] 0.005968456\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nНеобходимо создать функцию, аргументами которой будут две матрицы\nВнутри функции должен быть цикл, который будет перебирать столбцы матриц и выполнять на них t-тест\nИз результатов t-тесты необходимо извлекать три значения, аналогично заданию 6.\nИзвлеченные результаты должны сохраняться в список результатов, который необходимо создать в начале функции.\nВ конце тела функции с помощью return() нужно вернуть получившийся список с результатами.\nКоличество элементов списка результатов должно совпадать с числом колонок входных матриц.\n\n\n\n\n\n\n#8\n\n\nВыполните функцию из задания 7 на матрицах sim1 и sim2. Результат работы функции сохраните в переменную stat_testing_res.\n\n\n\nДля самопроверки в качестве ответа введите среднее значение (estimate) по выборке y (mean of y) из 30-го t-теста, округленное до сотых по арифметическим правилам.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#9\n\n\nИзвлеките из списка stat_testing_res вектор p-значений (p.value).\n\n\n\nДля самопроверки в качестве ответа введите десятое значение получившегося вектора, округленное до сотых по арифметическим правилам.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nЧтобы извлечь p-значения, необходимо выполнить функцию, которая извлекает p-значения, на элементах списка.\nИспользуйте для этого функцию Map()\nВ качестве её первого аргумента пропишите анонимную функцию, которая вытаскивает элемент p.value из списка путем индексации по имени.\nФункция Map() возвращается список, который необходимо превратить в вектор с помощью функции unlist().\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что в вектор извлекаются именно p-значения.\nПроверьте, что индексируете необходимый элемент вектора.\nПроверьте округление — округлить необходимо по арифметическим правилам: \\(9.434 \\rightarrow 9.43, \\, 9.435 \\rightarrow 9.44\\).\n\n\n\n\n\n\n#10\n\n\nПроверьте, сколько результатов тестов было статистически значимым. Считайте статистически значимым те результаты, где p-значение было меньше 0.05.\n\n\n\nДля самопроверки в поле ниже введите получившееся значение.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW2 // Матрицы и списки. Функции"
    ]
  },
  {
    "objectID": "hw2.html#hw2_add",
    "href": "hw2.html#hw2_add",
    "title": "HW2 // Матрицы и списки. Функции",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n#1\n\n\nМодифицируйте функцию из задания 2, чтобы в её аутпуте строки были подписаны соответственно mean и sd.\nСохраните модифицированную функцию в переменную mean_sd_1.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nПродолжите модификацию функции из задания 2, чтобы в её аутпуте столбцы унаследовали названия из входной матрицы, если они есть.\nСохраните модифицированную функцию в переменную mean_sd_2.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#3\n\n\nМодифицируйте функцию из задания 7, чтобы:\n\nона проверяла, совпадает ли количество столбцов во входных матрицах,\n\nв случае совпадения выполняла свой основной код\nв случае несовпадения заканчивала свою работу с ошибкой Number of columns does not match\n\nможно было задать параметр paired для t-тестов с дефолтным значением таким же, как у функции t.test()\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#4\n\n\nМодифицируйте функцию из предыдущего задания, чтобы можно было использовать для статистических тестов не только функцию t.test(), но и другие. Функция должна без ошибок обрабатывать входные параметры внутренних статистических функций. Сохраните модифицированную функцию в переменную stat_testing_2.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nНапишите функцию, которая решает квадратные уравнения.\nКвадратное уравнение задается тремя коэффициентами \\(a\\), \\(b\\) и \\(c\\):\n\\[\nax^2 + bx + c = 0\n\\]\nФункция должна:\n\nпринимать на вход три аргумента — коэффициенты квадратного уравнения \\(a\\), \\(b\\) и \\(c\\)\n\nкоэффициент \\(a\\) является обязательным, иначе уравнение не является квадратным\n\nзначение \\(a\\) не может равняться нулю по той же причине — функция должна в этом случае выдать ошибку The equation is not quadratic\n\nесли какой-либо из коэффициентов \\(b\\) и \\(c\\) не передан в функцию, его значение считается равным нулю\n\nвозвращать именованный вектор решений квадратного уравнения\n\nесли два решения различны, необходимо вернуть оба с именами x1 и x2 в порядке возрастания\nесли два решения совпадают, необходимо вернуть только одно с именем x\nесли решений нет, необходимо вернуть пропущенное значение и сообщение No solutions\n\n\nИзвестно, что уравнения вида \\(x^2 + 1 = 0\\) в общем случае корректны, и функция должна уметь их решать.\n\nПо умолчанию функция должна решать уравнение в вещественных числах.\nЕсли пользователь хочет, чтобы уравнение решалось в комплексных числах, ему необходимо указать аргумент функции complex = TRUE.\n\nСохраните функцию в переменную quadeqsolve.\nПримеры работы функции представлены ниже.\n\n\nquadeqsolve(a = 1, b = -5, c = 4)\n\nx1 x2 \n 1  4 \n\nquadeqsolve(b = -3, c = 2)\n\nError in quadeqsolve(b = -3, c = 2): argument \"a\" is missing, with no default\n\nquadeqsolve(a = 0, b = -3, c = 2)\n\nError in quadeqsolve(a = 0, b = -3, c = 2): The equation is not quadratic\n\nquadeqsolve(a = -4, c = 2)\n\n        x1         x2 \n 0.7071068 -0.7071068 \n\nquadeqsolve(a = 3, c = 2)\n\nNo solutions\n\n\n[1] NA\n\nquadeqsolve(a = 3, c = 2, complex = TRUE)\n\n          x1           x2 \n0-0.8164966i 0+0.8164966i\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW2 // Матрицы и списки. Функции"
    ]
  },
  {
    "objectID": "hw3.html",
    "href": "hw3.html",
    "title": "HW3 // Датафреймы. Исследование данных",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW3 // Датафреймы. Исследование данных"
    ]
  },
  {
    "objectID": "hw3.html#hw3_main",
    "href": "hw3.html#hw3_main",
    "title": "HW3 // Датафреймы. Исследование данных",
    "section": "",
    "text": "Заметка\n\n\n\nОписание данных\nСегодня мы работаем с данными опросника Тёмная дюжина (Dirty Dozen), которые собирались в одном из офлайн-исследований. Так как данные были собраны на разных компьютерах, несколько файлов были объединены в архив.\nТёмная дюжина — это опросник на Темную триаду из двенадцати пунктов. Данные содержат ответы респондентов на эти пункты (q1 — q12), идентификатор респондента (id) и дату, когда опросник был заполнен (date).\n\n\n\n#1\n\n\nСкачайте архив с данными и разархивируйте его в проект курса, который мы создали на практическом занятии. В папке проекта должна появиться папка hw3. Мы будем работать с ней.\nСколько всего файлов содержится в папке hw3? Выведете число файлов с помощью кода.\n\n\n\nДля самопроверки введите количество файлов в папке.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nНеобходимо вывести названия файлов, содержащихся в папке hw3 в виде вектора\nИ далее определить длину (количество элементов) этого вектора\n\n\n\n\nЧто надо сделать?\n\n\nВыведите названия файлов, содержащихся в папке hw3, с помощью функции dir()\nФункция вернет вектор названий файлов\nОпределите длину (количество элементов) этого вектора с помощью функции length()\n\n\n\n\nКод падает с ошибкой\n\n\nПроверьте, что вы разархивировали скачанный архив в папку проекта\nПроверьте, что вы работаете в проекте\nПроверьте, что вы не опечатались в названии папки\n\n\n\n\n\n\n#2\n\n\nДанные собирались на одном и том же программном обеспечении, поэтому структура файлов одинакова. Возьмите первый датасет set1.csv из папки с данными и загрузите его в переменную set1.\n\n\n\nДля самопроверки в поле ниже введите число строк в датасете.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#3\n\n\nПроверьте структуру полученного датафрейма. Выведите типы данных всех переменные и первые несколько значений каждой из них с помощью одной команды.\n\n\n\nВ качестве ответа для самопроверки введите название типа данных, переменных которого больше всего в датасете. Проверка примет только полное название типа.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nВыведете структуру датафрейма\nПосмотрите, переменных какого типа больше всего\n\n\n\n\nЧто надо сделать?\n\n\nС помощью функции str() вывести структуру датафрейма\nФункция вернет список переменных, их тип и первые несколько значений каждой из них\nОпределите, переменных какого типа больше всего\n\n\n\n\nОтвет неверный\n\nПроверьте, с помощью какой функции вы загружаете данные. В случае read.csv() ответ будет верный, в случае read_csv() из пакета tidyverse ответ будет отличаться.\n\n\n\n\n\n#4\n\n\n\nВыведите первые 15 строк датафрейма.\nВыведите 6 последних строк датафрейма.\n\n\n\n\nДля самопроверки введите через запятую id первого и последнего наблюдения (строки) в датасете.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nВыведите базовые описательные статистики по всем колонкам датасета с помощью одной функции.\n\n\n\nДля самопроверки в поле ниже введите среднее (mean) по переменной q6, округлённое до трёх десятичных знаков.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nЧто надо сделать?\n\n\nВыведите базовые описательные статистики по всем переменных датафрейма с помощью функции summary().\n\n\n\n\nОтвет неверный\n\nПроверьте, что вы вводите среднее значение именно для переменной q6.\n\n\n\n\n\n#6\n\n\nДанные первично исследованы. Теперь можно объединить все файлы в единый датасет.\nЗагрузите все файлы данных и объедините их в один датафрейм. Назовите его dd. Сделайте это с помощью цикла.\n\n\n\nВ качестве ответа для самопроверки введите количество строк в получившемся датафрейме.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nНапишите цикл, который проходится по вектору названий файлов, и читает каждый из указанных файлов\nУчтите, что функция dir() возвращает только названия файлов, а чтобы они были прочитаны, необходимо добавить к их названиям имя папки, в которой они лежат\nВ теле цикла необходимо присоединять только что прочитанный файл к уже прочитанным и перезаписывать переменную\nНе забудьте, что первый прочитанный файл также нужно к чему-то присоединить\n\n\n\n\nЧто надо сделать?\n\n\nВозьмите за основу функцию read.csv(), которая читает файлы, и возвращает датафрейм.\nИспользуйте функцию rbind(), чтобы объединить два датафрейма по строкам.\nЧтобы первый загруженный датафрейм было к чему присоединять, создайте пустой датафрейм функцией data.frame().\nПрисоединить имя папки к названию файла, чтобы сформировать полный путь, можно с помощью функции paste0().\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что цикл выполнился столько раз, сколько файлов есть в папке (посмотрите на значение переменной-итератора в Environment).\nПроверьте, что какой-либо из файлов не прочитался более одного раза.\n\n\n\n\n\n\n#7\n\n\nПроверьте, есть ли в файлах данные, собранные в разные года. Для этого поработайте с переменной date. Обратите внимание на её тип.\nДля выполнения понадобится библиотека lubridate.\n\n\n\nДля самопроверки в поле ниже введите нет, если в данных есть наблюдения из разных лет, и полученный год, если все данные собраны в одном году.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nОпределите тип переменной date и скорректируйте его — измените на datetime при необходимости.\nВыделите из даты год\nПосчитайте число уникальных значений\n\n\n\n\nЧто надо сделать?\n\n\nПроверьте тип переменной date с помощью функции class().\nПерезапишите переменную, приведя её к типу datetime с помощью соответствующей функции из пакета lubridate.\nЧтобы перезаписать переменную, необходимо использовать синтаксис с индексацией по имени вместе и оператором присваивания &lt;-\nВыделите из перезаписанной переменной date год с помощью соответствующей функции из lubridate.\nОпределите число уникальных значений года\n\n\n\n\n\n\n#8\n\n\nОтберите из всего датасета только те данные, которые были собраны в осенний период — сентябрь, октябрь, ноябрь. Сохраните результат в переменную dd_fall.\n\n\n\nВ качестве ответа для самопрверки введите количество строк в получившемся датафрейме.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nВыделите из переменной с датой месяц\nПроиндексируйте датафрей по необходимому условию аналогично индексации матрицы\nВ датафрейме необходимо сохранить все колонки\nСохраните результат в переменную\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\nПроверьте условия индексации — в сабсет должны попасть только месяца 9, 10 и 11.\n\n\n\n\n\n#9\n\n\nСоздайте в рабочей директории папку с названием hw3-prepdata.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#10\n\n\nЭкспортируйте датасет с осенними наблюдениями в созданную папку hw3-prepdata.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW3 // Датафреймы. Исследование данных"
    ]
  },
  {
    "objectID": "hw3.html#hw3_add",
    "href": "hw3.html#hw3_add",
    "title": "HW3 // Датафреймы. Исследование данных",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n#1\n\n\nНа практике мы создали проект для нашего курса. Давайте создадим в нем структуру.\nСоздайте в директории проекта три папки: data, scripts и graphs, в которых будут храниться данные, скрипты и визуализации, которые мы впоследствии будем создавать.\nРаспределите файлы, накопившиеся в ходе курса, по соответствующих папкам. Можете создать дополнительные подпапки внутри data, scripts и graphs, если считаете нужным. Задание выполняется без кода.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nНапишите функцию, которая загружает все файлы из папки в один датафрейм.\nФункция должна принимать на вход путь в папке и возвращать датафрейм, в котором будут содержать все данные из её файлов. Считайте, что папка содержит только файлы данных формата CSV, а их структура одинакова.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#3\n\n\nВозьмите файл и загрузите его в R c помощью функции read.table(). С ним есть проблема, которую вам необходимо решить. Тут есть полезный инструмент.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#4\n\n\nМодифицируйте функцию из дополнительного задания 2 так, чтобы она могла обрабатывать различные кодировки файлов. Основное поведение функции должно остаться прежним.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nПревратите директорию проекта курса в git-репозиторий (локальный или облачный).\nВыполните задание, если вы знакомы с git. Иначе, пропустите задание.\nЕсли вы создали облачный репозиторий, добавьте в скрипт комментарием ссылку на него.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW3 // Датафреймы. Исследование данных"
    ]
  },
  {
    "objectID": "hw4.html",
    "href": "hw4.html",
    "title": "HW4 // Предобработка данных",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW4 // Предобработка данных"
    ]
  },
  {
    "objectID": "hw4.html#hw4_main",
    "href": "hw4.html#hw4_main",
    "title": "HW4 // Предобработка данных",
    "section": "",
    "text": "Описание данных\n\n\n\nСегодня мы работаем с данными одного экспериментального исследования.\nЭксперимент был направлен на изучение гибридного зрительного поиска. Испытуемому было необходимо искать объекты из определенной категории. В качестве независимых переменных варьировались так называемые visual setsize и memory setsize, то есть количество стимулов, предъявляемых на экране монитора, и количество категорий, которые нужно было запомнить. Кроме того, использовались категории двух уровней — базовые (яблоки, кружки) и суперординатные (фрукты, посуда).\nДанные располагаются в двух файлах. В файле base.xlsx содержаться данные из группы испутыемых, которым предлагались базовые категории, в файле super.xlsx — данные из группы испутыемых, которым предлагались суперординатные категории.\nНа листе cor_answ в каждом файле есть данные по точности для каждого сочетания условий. Сочетания условий кодируются следующим образом: например, 1_stim_8 обозначает, что memory setsize был равен 1, а visual setsize был равен 8. То есть первое число задаёт memory setsize, второе — visual setsize. На этом же листе с правого края есть соцдем респондентов — пол и возраст. На листе Time располагаются аналогичным образом организованные данные по времени реакции (от момента начала предъявления стимулов до нажатия на клавишу).\nХотя данные, с которыми мы работаем, были частично предобработаны коллегой — это не сырые аутпуты PsychoPy — нам все равно придется с ними поработать, чтобы привести их к удобному для работы виду.\n\n\n\n#1\n\n\nСкачайте архив с данными. Разархивируйте файлы в проект курса. Импортируйте данные в R. У вас должно получиться 4 датасета с данными с 4-х листов Excel-файлов. Назовите их base_time, base_acc, super_time и suoer_acc для времени реакции и точности и условиях с базовыми и суперординатными категориями соответственно.\nВозникли ли какие-то странности?\n\n\n\nВ качестве ответа введите число строк, которые необходимо пропустить при импорте данных, чтобы они прочитались корректно.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nНеобходимо скачать архив с данными и разархивировать его в проект курса.\nДалее нужно загрузить четыре датасета в четыре разных объекта, прочитав данные из Excel-файлов.\nПосле загрузки проверьте, корректно ли загрузились данные. При необходимости воспользуйтесь документацией в функций чтения данных.\n\n\n\n\nЧто надо сделать?\n\n\nСкачайте архив с данными и разархивируйте его в проект курса.\nЗагрузите датасеты из Excel-файлов с помощью функции read_xlsx() из пакета readxl.\nОбратите внимание, как прочитались заголовки колонок. Откройте справку по функции read_xlsx() — ?read_xlsx — и ознакомьтесь в работой аргeмента skip.\nСкорректируйте код загрузки данных.\n\n\n\n\n\n\n#2\n\n\nПроверьте, совпадает ли количество строк в получившихся датасетах.\n\n\n\nДля самопроверки введите число строк, если оно совпадает во всех датасетах, и нет, если оно отличается хотя бы в одном.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#3\n\n\nВыгрузите соцдем, содержащийся в данных, в отдельный датасет. Соедините обе его части в один объект.\n\n\n\nВ качестве ответа введите число пропущенных значений в получившемся датасете. Если их нет, введите 0.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nОпределите, в каких датасетах и колонках содержится соцдем в представленных данных.\nОтберите необходимые колонки из данных.\nЕсли соцдем находится в нескольких датасетах, объедините все имеющиеся части в один объект.\n\n\n\n\nЧто надо сделать?\n\n\nПосмотрите в описании, как организованы данные и в какую их часть записан соцдем.\nИзвлеките необходимые колонки с помощью select().\nПри необходимости объедините части соцдема в один объект с помощью bind_rows().\n\n\n\n\n\n\n#4\n\n\nУдалите пропущенные значения из данных соцдема, если они есть, и задайте имена колонок — sex и age соответственно.\n\n\n\nДля самопроверки введите общее количество испытуемых в выборке эксперимента.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nУдалите из данных эксперимента лишние строки и столбцы. В объектах должно остаться только то, что относится к экспериментальным данным. Лишними считайте те столбцы, которые не имеют названия, и те строки, в которых не указан идентификатор респондента. Перезапишите имеющиеся объекты.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nИзучите структуру датасетов с экспериментальными данными. Найдите в ней общие паттерны.\nВ данном случае из-за сходной структуры данных уместно написать короткую функцию, которая будет отбирать из датасетов только те строки и столбцы, в которых содержатся экспериментальные данные.\nПримените функцию на имеющихся датасетах и перезапишите имеющиеся объекты, сохранив в них только экспериментальные данные.\n\n\n\n\nЧто надо сделать?\n\n\nИзучите структуру датасетов с экспериментальными данными и определите номера колонок и строк, которые нобходимо отобрать.\nНапишите функцию, которая будет принимать на вход датасет и отбирать из него необходимые колонки и строки — подойдут select() и slice().\nПримените функцию на имеющихся датасетах и перезапишите имеющиеся объекты, сохранив в них только экспериментальные данные.\n\n\n\n\n\n\n#6\n\n\nСоздайте в датасетах эксперимента новую переменную group, содержащую информацию об уровне категории — базовая (base) или суперординатная (super).\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#7\n\n\nСоедините датасеты с данными о точности и времени реакции друг с другом — base_acc с super_acc и base_time с super_time. Назовите новые датасеты acc и time соответственно.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nИсходя из структуры имеющихся данных, выберите подходящий способ объединения датасетов и необходимую для этого функцию. В обоих случаях датасеты объдиняются одинаково.\n\n\n\n\n#8\n\n\nСейчас получившиеся датасеты пребывают в широком формате. Переведите их в длинный формат и разделите колонку с сочетанием экспериментальных условий на две.\nВ датасете должны содержаться следующие колонки:\n\nid — идентификатор испытуемого\nvisual_setsize — количество стимулов в пробе\nmemory_setsize — количество категорий для запоминания\nreaction_time/accuracy — время реакции / точность (в зависимости от датасета)\n\nПри необходимости переименуйте столбцы.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля корректного приведения к длинному формату, определите колонки, которые не должны участвовать в преобразовании.\nРазделяя колонку с сочетанием экспериментальных условий, задайте разделитель, наиболее подходящий для значений, которые в ней содержатся.\n\n\n\n\n\n#9\n\n\nОбъедините все данные в один датасет, который будет содержать следующие колонки:\n\nid — идентификатор испытуемого\ngroup — уровень категории\nvisual_setsize — количество стимулов в пробе\nmemory_setsize — количество категорий для запоминания\nreaction_time — время реакции\naccuracy — точность\n\nСохраните результат в переменную hybrid.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nИсходя из структуры имеющихся данных, выберите подходящий способ объединения датасетов и необходимую для этого функцию.\n\n\n\n\n#10\n\n\nНа получившемся датасете рассчитайте среднее, минимальное и максимальное время реакции, а также его стандартное отклонение, по всем сочетаниям независимых переменных.\n\n\n\nДля самопроверки в поле ниже введите среднее время реакции в группе base при visual_setsize 12 и memory_sesize 4, округленное до третьего знака после запятой.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW4 // Предобработка данных"
    ]
  },
  {
    "objectID": "hw4.html#hw4_add",
    "href": "hw4.html#hw4_add",
    "title": "HW4 // Предобработка данных",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n#1\n\n\nВ нашем случае названия файлов данных, которые у нас есть, содержат названия экспериментальных условий (base.xlsx и super.xlsx). Нам повезло, что эти название короткие, простые и их всего два — мы можем задать их вручную. Однако так случается не всегда, и хорошо автоматизировать этот процесс, чтобы не допустить лишних опечаток.\nНапишите код, с помощью которого можно вытащить вектор с экспериментальными условиями из названий файлов.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nВ ходе выполнения заданий вы могли заметить, что часто мы выполняли одни и те же преобразования с разными датасетами. Так как входные датасеты имеют схожую структуру, можно оптимизировать усилия.\nНапишите функцию, которая будет:\n\nпринимать на вход путь к файлу, в котором лежат данные\n\nа также другие необходимые для предобработки аргументы\n\nпредобрабатывать их\nвозвращаемое задание может различаться в зависимости от способа реализации функции\n\nТело функции соберите из кода, который вы написали в ходе выполнения задания основной части.\nПри необходимости можете использовать написанную функцию в какой-либо другой последовательности предобработки. По итогам предобработки должен получиться датасет, идентичный датасету hybrid, полученному в задании 9.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n\n\n\n\nГенерируем координаты\n\n\n\nСледующие три задания посвящены написанию кода для генерации координатной сетки для стимулов в зрительном поиске.\nОбщий вид координатной сетки выглядит так:\n\n\n\n\nОбщая схема координатной сетки. Разрешение экрана — 1920×1080 пикселей. Координаты центра экрана — [0, 0]. Отступ от края экрана 100 пикселей с каждой стороны.\n\n\n\nВ данном случае мы будем генерировать сетку для 21 стимула — в 3 ряда по 7 в каждом. На пересечении черных линий располагаются центры стимулов.\n\n\n\n\nОбщая схема координатной сетки с расположением центров стимулов.\n\n\n\nПоскольку стимулы не могут отображаться на одном и том же месте в каждой пробе, задается область, в которой стимул может свободно колебаться от пробы к пробе. Однако чтобы они на сталкивались друг с другом, предусматривается зазор между областями их свободного колебания.\n\n\n\n\nОбщая схема координатной сетки с расположением центром стимулов. Синим обозначены области, в которых стимулы могут свободно колебаться. Красным обозначен зазор, препятствующий столкновению стимулов.\n\n\n\n\n\n\n\n\n\n\n\nИсходные параметры для генерации координатной сетки\n\n\n\n\nРазрешение (размер) экрана (res_x×res_y): 1920×1080\nЗазор между областями колебания стимулов (gap): 10\nКоличество стимулов по ширине экрана (n_x): 7\nКоличество стимулов по высоте экрана (n_y): 3\nГоризонтальный отступ от края экрана (margin_x): 100\nВертикальный отступ от края экрана (margin_y): 100\nГоризонтальный размер стимула (stim_size_x): 100\nВертикальный размер стимула (stim_size_y): 100\nКоличество проб, для которых надо сгенерировать координаты (n_trials): 30\n\nВсе значения указаны в пикселях, кроме количества проб.\n\n\n\n\n#3\n\n\nРассчитайте координаты центров стимулов.\nНеобходимо получить два вектора — centers_x и centers_y — которые будут содержать координаты центров стимулов по x и по y соответственно. Количество значений в векторах должно совпадать с количетвом стимулов по ширине и высоте экрана соответственно.\nИсходными параметрами, необходимым для расчета координат центра являются res_x, res_y, margin_x, margin_y, n_x, n_y.\n\n\n\nДля самопроверки в поле ниже введите через запятую значения координат центров по x, затем точку с запятой, а далее — значения координат центров по y. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nИспользуя данные о разрешении экрана, рассчитайте расстояния между центрами стимулов по x и y с учетом отступов от краёв экрана.\nСоздайте две последовательности от самого левого (нижнего) положения стимула до самого правого (верхнего) положения стимула с шагом, равным расстоянию между центрами стимулов.\nСкорректируйте координаты с учетом позиции начала координат в центре экрана.\n\n\n\n\nЧто надо сделать?\n\n\nРассчитайте расстояния между центрами стимулов.\n\nВычтите из разрешения экрана отступы, чтобы получить размеры поля, где могут располагаться стимулы.\nРазделите соответствующие размеры на количество необходимых расстояний.\nРасстояний между стимулами на одно больше, чем самих стимулов (см. рисунки выше).\n\nСгенерируйте последовательности соответствующих координат центров стимулов:\n\nДля x от самого левого до самого правого положения стимула с шагом, равным расстоянию между центрами по x.\nДля y от самого нижнего до самого верхнего положения стимула с шагом, равным расстоянию между центрами по y.\n\nСкорректируйте координаты с учетом позиции начала координат в центре экрана: из полученных координат вычтите половину разрешения экрана по горизонтали и вертикали соответственно.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, правильно ли заданы входные параметры для расчета координат.\nПроверьте, разделили ли вы значения в векторах запятыми.\nПроверьте, отделили ли вы вектора друг от друга точкой с запятой.\n\n\n\n\n\n\n#4\n\n\nРассчитайте, на сколько максимально стимул может отклоняться по вертикали и горизонтали от координат центра, чтобы не сталкиваться с другими стимулами (jitter_x и jitter_y). Так как отклонения будут симметричны, учтите только одну сторону отклонения по одной оси — влево и вниз или вправо и вверх.\nИсходными параметрами, необходимым для расчета максимального отклонения являются gap, stim_size_x, stim_size_y, а также расстояние между центрами стимулов.\nЕсли в ходе вычислений получаются нецелые значения, округлите их до ближайшего целого вниз.\n\n\n\nДля самопроверки введите через запятую значения jitter_x и jitter_y. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nСгенерируйте координаты стимулов для нескольких экспериментальных проб.\n\nКоличество проб задано параметров n_trials.\nИтоговый датасет должен содержать колонку trial, которая будет задавать номер пробы, и колонки pos1…posN, где N — общее количество стимулов на экране. Таким образом, в каждой колонке должны быть заданы координаты для отдельного стимула на экране. Количество стимулов на экране определяется параметрами n_x и n_y.\nКоординаты в колонках pos1…posN должны быть представлены в формате [x,y]. Между символами не должно быть пробелов.\nДля каждого стимула в каждой пробе должны быть сгенерированы уникальные координаты с учетом возможного колебания стимула вокруг координат его центра. Диапазон колебаний по обеим осям задается значениями jitter_x и jitter_y.\n\nНиже представлен вариант итогового датасета.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntrial\npos1\npos2\npos3\npos4\npos5\npos6\npos7\npos8\npos9\npos10\npos11\npos12\npos13\npos14\npos15\npos16\npos17\npos18\npos19\npos20\npos21\n\n\n\n\n1\n[-667,-268]\n[-404,-219]\n[-217,-203]\n[-39,-224]\n[229,-179]\n[419,-209]\n[642,-236]\n[-655,-54]\n[-382,9]\n[-254,17]\n[-28,-49]\n[252,21]\n[468,-27]\n[661,-36]\n[-607,242]\n[-426,244]\n[-176,171]\n[-44,264]\n[255,209]\n[476,240]\n[664,189]\n\n\n2\n[-672,-185]\n[-476,-263]\n[-226,-192]\n[-44,-266]\n[245,-182]\n[413,-235]\n[670,-264]\n[-617,-48]\n[-440,15]\n[-165,-41]\n[23,27]\n[177,-7]\n[409,51]\n[599,-17]\n[-689,251]\n[-442,199]\n[-194,170]\n[-30,235]\n[189,168]\n[437,238]\n[645,245]\n\n\n3\n[-691,-228]\n[-430,-268]\n[-241,-223]\n[43,-209]\n[200,-168]\n[466,-223]\n[626,-166]\n[-605,45]\n[-414,-42]\n[-196,-28]\n[23,-50]\n[225,-47]\n[390,-23]\n[674,-10]\n[-601,228]\n[-392,183]\n[-243,265]\n[-15,262]\n[183,165]\n[456,256]\n[633,216]\n\n\n4\n[-651,-182]\n[-393,-208]\n[-208,-186]\n[42,-201]\n[178,-271]\n[471,-176]\n[598,-257]\n[-626,-21]\n[-397,-23]\n[-182,47]\n[-14,13]\n[193,5]\n[458,-33]\n[642,-15]\n[-664,253]\n[-479,227]\n[-255,213]\n[16,249]\n[187,233]\n[429,228]\n[614,240]\n\n\n5\n[-609,-274]\n[-451,-258]\n[-243,-272]\n[34,-170]\n[197,-165]\n[417,-189]\n[622,-204]\n[-686,9]\n[-452,19]\n[-238,45]\n[11,-45]\n[261,23]\n[391,23]\n[685,1]\n[-602,220]\n[-412,270]\n[-201,179]\n[-30,243]\n[241,216]\n[462,272]\n[629,269]\n\n\n6\n[-690,-215]\n[-432,-187]\n[-194,-240]\n[-3,-273]\n[260,-269]\n[451,-208]\n[678,-172]\n[-622,-3]\n[-399,45]\n[-222,-32]\n[-36,46]\n[224,12]\n[423,11]\n[646,-45]\n[-663,238]\n[-379,257]\n[-174,251]\n[26,169]\n[186,252]\n[464,196]\n[599,253]\n\n\n7\n[-605,-265]\n[-404,-202]\n[-245,-197]\n[-27,-216]\n[264,-245]\n[409,-202]\n[599,-231]\n[-671,3]\n[-441,-32]\n[-263,-21]\n[17,-46]\n[178,8]\n[401,16]\n[624,-12]\n[-677,206]\n[-428,196]\n[-193,203]\n[-17,171]\n[245,202]\n[466,181]\n[631,248]\n\n\n8\n[-644,-243]\n[-393,-175]\n[-259,-202]\n[18,-167]\n[260,-202]\n[425,-274]\n[669,-197]\n[-615,31]\n[-427,55]\n[-229,48]\n[15,43]\n[163,10]\n[417,14]\n[622,54]\n[-604,223]\n[-394,211]\n[-252,173]\n[35,187]\n[216,189]\n[452,179]\n[640,250]\n\n\n9\n[-678,-204]\n[-379,-183]\n[-201,-171]\n[40,-255]\n[198,-228]\n[429,-203]\n[614,-178]\n[-649,49]\n[-441,-13]\n[-209,0]\n[31,19]\n[173,-52]\n[432,15]\n[600,0]\n[-652,214]\n[-398,175]\n[-202,261]\n[24,239]\n[208,224]\n[447,266]\n[664,249]\n\n\n10\n[-654,-202]\n[-451,-209]\n[-232,-177]\n[-8,-178]\n[176,-218]\n[393,-236]\n[679,-184]\n[-665,-43]\n[-443,-48]\n[-228,-54]\n[-43,-50]\n[251,31]\n[449,-39]\n[674,-24]\n[-689,242]\n[-476,235]\n[-261,241]\n[5,236]\n[223,266]\n[451,239]\n[616,270]\n\n\n11\n[-635,-259]\n[-429,-205]\n[-245,-221]\n[-27,-168]\n[195,-257]\n[434,-172]\n[621,-261]\n[-688,-10]\n[-430,-42]\n[-214,34]\n[24,-29]\n[173,25]\n[402,-23]\n[644,-6]\n[-672,182]\n[-476,184]\n[-243,255]\n[34,206]\n[252,238]\n[409,217]\n[676,227]\n\n\n12\n[-674,-203]\n[-426,-245]\n[-195,-193]\n[52,-221]\n[263,-258]\n[400,-168]\n[606,-232]\n[-692,36]\n[-392,-35]\n[-267,-27]\n[37,-20]\n[220,28]\n[458,-33]\n[621,-14]\n[-672,233]\n[-456,230]\n[-183,246]\n[-46,240]\n[222,226]\n[403,228]\n[633,241]\n\n\n13\n[-614,-169]\n[-477,-225]\n[-174,-174]\n[-22,-258]\n[255,-266]\n[394,-203]\n[656,-177]\n[-661,37]\n[-426,30]\n[-248,27]\n[-18,16]\n[251,53]\n[410,41]\n[658,-54]\n[-694,207]\n[-409,169]\n[-171,249]\n[-48,259]\n[187,264]\n[385,191]\n[647,187]\n\n\n14\n[-609,-273]\n[-398,-261]\n[-223,-170]\n[-35,-173]\n[204,-218]\n[408,-269]\n[598,-242]\n[-627,-25]\n[-422,26]\n[-163,-38]\n[-5,43]\n[179,48]\n[422,-10]\n[684,-47]\n[-635,243]\n[-430,181]\n[-164,171]\n[0,258]\n[225,172]\n[448,229]\n[676,173]\n\n\n15\n[-616,-177]\n[-390,-251]\n[-251,-274]\n[44,-265]\n[164,-208]\n[426,-236]\n[594,-256]\n[-685,-45]\n[-459,-38]\n[-219,-2]\n[14,-42]\n[244,11]\n[379,36]\n[629,11]\n[-635,274]\n[-407,256]\n[-255,257]\n[-11,203]\n[223,187]\n[447,243]\n[630,251]\n\n\n16\n[-634,-188]\n[-403,-236]\n[-169,-243]\n[-17,-239]\n[253,-216]\n[468,-247]\n[627,-206]\n[-611,-31]\n[-416,-14]\n[-173,-30]\n[-5,32]\n[228,-12]\n[400,40]\n[659,-48]\n[-689,180]\n[-422,203]\n[-229,260]\n[41,267]\n[193,229]\n[471,258]\n[665,222]\n\n\n17\n[-662,-187]\n[-385,-220]\n[-246,-233]\n[-9,-209]\n[203,-220]\n[469,-254]\n[685,-259]\n[-655,28]\n[-444,43]\n[-231,-42]\n[-20,45]\n[245,8]\n[389,-32]\n[690,38]\n[-677,172]\n[-402,184]\n[-192,238]\n[41,250]\n[197,214]\n[407,181]\n[681,173]\n\n\n18\n[-648,-241]\n[-436,-175]\n[-201,-191]\n[29,-213]\n[258,-219]\n[458,-260]\n[694,-224]\n[-656,34]\n[-443,43]\n[-226,-21]\n[43,-2]\n[188,-30]\n[390,-43]\n[612,-20]\n[-596,211]\n[-463,189]\n[-175,192]\n[31,193]\n[256,241]\n[418,208]\n[600,218]\n\n\n19\n[-659,-191]\n[-409,-251]\n[-187,-247]\n[10,-256]\n[244,-183]\n[481,-263]\n[603,-199]\n[-696,-21]\n[-464,-1]\n[-191,-51]\n[-40,0]\n[193,21]\n[407,31]\n[614,36]\n[-604,208]\n[-409,236]\n[-252,202]\n[16,188]\n[198,244]\n[427,239]\n[625,251]\n\n\n20\n[-618,-182]\n[-455,-180]\n[-219,-185]\n[-41,-168]\n[215,-228]\n[405,-261]\n[658,-211]\n[-648,-2]\n[-407,52]\n[-221,-46]\n[-2,30]\n[168,-14]\n[457,44]\n[607,-15]\n[-679,189]\n[-424,258]\n[-265,216]\n[44,201]\n[195,191]\n[425,237]\n[667,247]\n\n\n21\n[-598,-241]\n[-438,-242]\n[-258,-213]\n[-11,-189]\n[186,-200]\n[469,-197]\n[695,-227]\n[-680,-21]\n[-402,-27]\n[-184,15]\n[6,37]\n[171,-11]\n[430,54]\n[603,-22]\n[-690,237]\n[-478,211]\n[-239,165]\n[-3,174]\n[232,205]\n[451,205]\n[618,203]\n\n\n22\n[-625,-168]\n[-472,-189]\n[-262,-270]\n[43,-244]\n[238,-173]\n[460,-215]\n[683,-196]\n[-642,34]\n[-387,-40]\n[-241,-54]\n[41,-22]\n[230,22]\n[465,-26]\n[620,-28]\n[-631,249]\n[-443,251]\n[-262,222]\n[-17,194]\n[217,253]\n[471,203]\n[640,234]\n\n\n23\n[-688,-208]\n[-458,-209]\n[-230,-230]\n[47,-217]\n[267,-166]\n[402,-228]\n[596,-266]\n[-619,-28]\n[-431,20]\n[-246,11]\n[-29,-55]\n[201,-12]\n[424,-7]\n[652,-23]\n[-635,200]\n[-446,177]\n[-222,243]\n[1,241]\n[209,210]\n[456,258]\n[608,182]\n\n\n24\n[-679,-168]\n[-411,-226]\n[-237,-173]\n[-16,-250]\n[265,-240]\n[425,-240]\n[652,-220]\n[-636,1]\n[-403,-53]\n[-259,33]\n[-42,-45]\n[205,-5]\n[407,-26]\n[653,-40]\n[-624,275]\n[-428,175]\n[-207,266]\n[-19,260]\n[219,259]\n[415,265]\n[676,230]\n\n\n25\n[-635,-254]\n[-437,-259]\n[-190,-271]\n[17,-197]\n[180,-180]\n[379,-214]\n[664,-241]\n[-623,35]\n[-462,-34]\n[-211,7]\n[18,33]\n[249,-41]\n[449,-21]\n[651,-26]\n[-624,198]\n[-446,233]\n[-187,233]\n[2,235]\n[168,166]\n[417,244]\n[598,268]\n\n\n26\n[-670,-253]\n[-451,-189]\n[-219,-188]\n[46,-255]\n[254,-194]\n[461,-257]\n[657,-267]\n[-629,27]\n[-408,6]\n[-221,54]\n[-33,27]\n[164,13]\n[439,-11]\n[655,24]\n[-636,267]\n[-473,268]\n[-209,196]\n[-4,212]\n[169,179]\n[438,190]\n[630,184]\n\n\n27\n[-662,-241]\n[-460,-221]\n[-234,-245]\n[35,-252]\n[166,-259]\n[431,-205]\n[621,-219]\n[-640,21]\n[-396,-21]\n[-193,2]\n[44,-2]\n[218,-43]\n[428,22]\n[642,12]\n[-650,189]\n[-480,193]\n[-235,217]\n[41,180]\n[196,205]\n[443,173]\n[656,201]\n\n\n28\n[-658,-222]\n[-425,-190]\n[-248,-166]\n[25,-168]\n[187,-190]\n[448,-252]\n[632,-262]\n[-637,-26]\n[-384,53]\n[-173,6]\n[-31,55]\n[242,-16]\n[463,53]\n[685,39]\n[-642,203]\n[-450,265]\n[-204,236]\n[0,275]\n[193,178]\n[423,212]\n[664,229]\n\n\n29\n[-674,-253]\n[-423,-250]\n[-238,-230]\n[-30,-253]\n[263,-181]\n[473,-213]\n[609,-255]\n[-608,25]\n[-424,-17]\n[-211,15]\n[-10,-11]\n[185,-9]\n[467,20]\n[692,40]\n[-653,210]\n[-475,247]\n[-189,224]\n[-17,247]\n[229,253]\n[416,181]\n[625,173]\n\n\n30\n[-660,-167]\n[-393,-166]\n[-240,-253]\n[37,-245]\n[243,-238]\n[464,-243]\n[645,-196]\n[-596,4]\n[-473,16]\n[-166,-51]\n[-12,7]\n[170,18]\n[378,-15]\n[672,36]\n[-632,201]\n[-379,210]\n[-190,247]\n[-41,261]\n[252,180]\n[449,170]\n[633,216]\n\n\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nПолезные функции:\n\nouter()\nas.vector()\nrep()\nseparate(), unite()\nsample()\nmutate()\npaste(), str_c()\npivot_wider()",
    "crumbs": [
      "HW4 // Предобработка данных"
    ]
  },
  {
    "objectID": "hw5.html",
    "href": "hw5.html",
    "title": "HW5 // Визуализация данных",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW5 // Визуализация данных"
    ]
  },
  {
    "objectID": "hw5.html#hw5_main",
    "href": "hw5.html#hw5_main",
    "title": "HW5 // Визуализация данных",
    "section": "",
    "text": "Общее задание на домашку\n\n\n\nВ данной домашке вам предлагается повторить представленную ниже визуализацию. Данные расположены здесь — это тот самый поведенческий эксперимент, с которым мы знакомились на четвертой практике.\n\nВ исследовании изучался зрительный поиск иконок различных платформ смартфонов. Испытуемым надо было искать иконки поделиться (share) iOS и Android среди дисктракторов — других иконок, которые для обеих платформ отрисованы одинаково. Целевой стимул мог быть один — два условия: иконка iOS (Outgoing Tray, tray) и иконка Android (Three Dots, dots) — или их могло быть два — и тот, и другой. Дополнительно варьировалось количество стимулов в пробе — 8, 12, 16. Фиксировалось время поиска целевого стимула (время реакции) — от начала пробы до клика испытуемого — а также координаты клика для вычисления точности поиска. Дополнительно были записаны данные об используемой платформе смартфона — iOS или Android.\n\nПеременные в датасете:\n\nid — идентификатор испытуемого\ntrialtype — тип пробы (dots / tray / both)\nsetsize — количество стимулов в пробе (8 / 12 / 16)\nplatform — платформа, которой пользуется испытуемый (ios / android)\ntime1 — время первого клика, с\ntime2 — время второго клика, с\ncorrect1 — является ли первый клик верным\ncorrect2 — является ли второй клик верным\n\nЕсть два варианта выполнения данной домашки:\n\nЕсли вы хорошо разобрались в ggplot2, то можете просто повторить визуализацию без опоры на задания.\n\nТолько посмотрите в конце задание 10 — надо экспортировать получившийся график.\n\nЕсли вы чувствуете, что ещё не очень уверенный пользователь ggplot2, то в заданиях поэтапно идёт движение с самого начала до итоговой визуализации.\n\nВид графика, который должен получиться в итоге вот:\n\n\n\n\n\n\n\n\n\n\n\n\n#1\n\n\n\nЗагрузите данные.\nПостройте базовую визуализацию, на которой будет отображено среднее время первого клика в условиях с разным количеством стимулов. Количество стимулов считайте категориальной переменной.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nОшибка при чтении файла\n\nФайл с данными содержит нетипичные разделители — как между колонками данных, так и десятичный разделитель. Чтобы корректно прочитать файл, используйте read_delim().\n\n\n\nКатегориальный setsize\n\nОбратите внимание на то, как распознается переменная setsize функцией чтения данных. Возможно, нужно что-то типа as_factor().\n\n\n\n\n\n#2\n\n\n\nДобавьте на визуализацию группировку наблюдений по типу пробы с помощью цвета и группировку по платформа с помощью формы точек. Из типа пробы в визуализации должны присутствовать только tray и dots.\nДобавьте на визуализацию доверительные интервалы для каждого из рассчитанных средних. Средните с доверительными интервалами не должны располагаться на одной вертикальной линии — немного разнесите их вправо-влево.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак убрать одно экспериментальное условие?\n\nОтфильтруйте из датасета лишние пробы.\n\n\n\nКак отодвинуть друг от друга средние с доверительными интервалами?\n\nposition_dodge()\n\n\n\nОшибка undefined column selected\n\nПроверьте, когда вы используете fun, а когда fun.data внтури stat_summary().\n\n\n\n\n\n#3\n\n\nСоедините точки, соответствующие одной группе в сочетании переменных trialtype и platform линиями.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nЛиний нет ((\n\nПроверье, указали на вы ggplotу, какие именно точки надо соединить — что считать одной группой точек, которые должны быть соединены линией.\n\n\n\nЛинии существуют отдельно от точек ((\n\nПроверьте, указали ли вы, что линии надо раздвинуть так же, как и средние с доверительными инетрвалами.\n\n\n\n\n\n#4\n\n\nНемного настройте график:\n\nувеличьте размер точек до 3, чтобы они были лучше видны\nсделайте линии прерывистыми, чтобы они меньше отвлекали внимание от точек\nзадайте линиям прозрачность в 30%, чтобы они еще меньше отвлекали внимание от точек\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nПрерывистая линия это какая?\n\ndashed\n\n\n\nСлишком прозравные линии получаются\n\nАргумент alpha задает непрозрачность. В задании же указано, насколько должна быть прозрачной линия.\n\n\n\n\n\n#5\n\n\nЕщё немного настройте график: задайте ширину усов доверительных интервалов в 30%.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#6\n\n\nЗадайте соответствующие подписи осей и легенды графика:\n\nось \\(x\\) — Количество стимулов в пробе\nось \\(y\\) — Время реакции (первый клик), с\nцвет — Тип пробы\nформа точек — Платформа\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#7\n\n\nДобавьте на график заголовок, подзаголовок и подпись.\n\nзаголовок — Время реакции при взаимодействии факторов\nподзаголовок — Тип пробы × Платформа × Количество стимулов в пробе\nподпись — отображен 95% доверительный интервал\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#8\n\n\n\nИзмените палитру используемых цветов на черно-белую — black и gray50.\nЗадайте значения подписей легенды:\n\nплатформы должны быть подписаны iOS и Android соответственно\nтип пробы Three Dots и Outgoing Tray соответственно\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак кастомизировать шкалы?\n\nscale_color_..() или scale_shape_..()\n\n\n\nКак задать соответствие между новыми подписями и исходными значениями?\n\nС помощью именованного вектора\n\n\n\n\n\n#9\n\n\nПоследние штрихи:\n\nРасположите легенду под визуалиацией.\nЗадайте черно-белую тему графику, чтобы убрать серый фон.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#10\n\n\nЭкспортируйте график в формате JPEG (размер — 20×18 см) в разрешении, подходящем для печати.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW5 // Визуализация данных"
    ]
  },
  {
    "objectID": "hw5.html#hw5_add",
    "href": "hw5.html#hw5_add",
    "title": "HW5 // Визуализация данных",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n#1\n\n\nПришла рецензия на статью, где был опубликован график, который вы сделали в основной части домашки. У рецензента нет никаких замечаний, кроме одного — он желает, что шрифт на графике был с засечками (Times New Roman), а название графика было выделено жирным начертанием.\nЧто ж… Сделаем.\n\nЗадайте Times New Roman в качестве шрифта для текста на графике.\nЗадайте полужирное начертание для заголовка графика.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nПошалим!\nПо ссылке вы найдете часть данных апробации опросника на доверие к искусственному интеллекту (Trust in Artшficial Intelligent Agents Scale). Это уже агрегированные данные — в них три столбца:\n\nid — идентификатор респондента\nsubscale — субшкала опросника\nsubscale_score — балл по данной субшкале\n\nПостроим профили для первых пяти респондентов.\n\nПрофиль должен быть отображен в виде столбчатой диаграммы\nНад каждым столбиком должен быть подписан балл респондента по шкале\nСтолбики должны различаться по цветам, однако легенда должна быть скрыта, чтобы не дублировать отображение переменной на оси\nКаждый профиль должен быть отображен на отдельном подграфике\n\nПример визуализации представлен ниже.\n\n\n\n\n\n\n\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\ngeom_label()\nguides()\n\n\n\n\n#3\n\n\nНа основе графика из предыдущего задания постройте визуализацию профилей респондентов 22, 23 и 24 и форме лучевой диаграммы.\nПример графика представлен ниже.\n\n\n\n\n\n\n\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\ncoord_polar()\ntheme(axis.title.x = element_text(...),\n        axis.text.x = element_text(...))\n\n\n\n\n#4\n\n\nПомимо знакомых нам форматов JPEG и PNG, которые являются растровыми, есть еще векторные форматы, которые позволяют масштабировать. Один из них SVG. Ему не важно, какого размера и какого разрешения вы хотите экспортировать картинку — её можно будет растянуть до любого размера.\nЭкспортируйте получившийся в предыдущем задании график с формате SVG.\nСкорее всего, понадобится установить пакет svglite.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nНапоследок нарисуем что-то невероятное — а именно, вокалическое пространство русского языка!\nВ двух словах: гласные звуки характеризуются двумя частотными характеристиками, которые называются форманты. Они задают координаты вокалического пространства. Расположение конкретных звуков на этих координатах и будет являться визуализацией вокалического пространства.\nВ датасете собраны различные харакретистики гласных звуков русского языка из произнесений разных слов. Нас будут интересовать прежде всего две характеристики:\n\nf1 — первая форманта, которая будет задавать вертикальную ось вокалического пространства\nf2 — вторая форманта, которая будет задавать горизонтальную ось вокалического пространства\n\nКроме этих двух переменных нам также понадобятся:\n\nphoneme — обозначение фонемы\nreduction — степень редукции\n\nВизуализируйте вокалическое пространство русского языка как показано на рисунке ниже. Обратите внимание на направление осей. Эллипсы отображают 80% доверительную зону для пары срених значений первой и второй формант.\n\n\n\n\n\n\n\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЧтобы задать новые подписи для фасетов, воспользуйтесь аргументом labeller функции facet_..(), в который необходимо передать результат работы функции labeller().\nЧтобы обозначить перенос строки, используйте символ \\n.\nЧтобы отобразить доверительные зоны для пар средних значений, есть функция stat_ellipse() с аргументом level.",
    "crumbs": [
      "HW5 // Визуализация данных"
    ]
  },
  {
    "objectID": "hw6.html",
    "href": "hw6.html",
    "title": "HW6 // Случайный эксперимент. Случайные величины",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW6 // Случайный эксперимент. Случайные величины"
    ]
  },
  {
    "objectID": "hw6.html#hw6_main",
    "href": "hw6.html#hw6_main",
    "title": "HW6 // Случайный эксперимент. Случайные величины",
    "section": "",
    "text": "#1\n\n\nПо ссылке расположен файл .RData с симуляцией трёх восьмигранных игральный кубиков dice1, dice2 и dice3. Один из них является честным, другой — нечестным, а третий — невозможным.\nВыясните, какой именно каким является.\nСимуляции представляют собой функции, которые принимают на вход число бросаний кубика n и возвращают вектор длины n с исходами бросаний кубиков.\n\n\n\n\n\n\nЗагрузить файл .RData\n\n\n\nДля загрузки симуляций в окружение воспользуйтесь следующим кодом:\n\nload(url(\"link/to/file\"))\n\n\n\n\n\n\nВ качестве ответа для самопроверки введите через запятую номера кубиков в следующем порядке — честный, нечестный, невозможный. Формат ввода 1,2,3. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nЗагрузите файл .RData с помощью кода из задания — в окружении должны отобразиться три функции dice1, dice2 и dice3.\nИспользуя классический подход к вероятности, рассчитайте ожидаемые вероятности, с которыми будут выпадать значения при бросании честного игрального кубика.\nИспользуя статистический подход к вероятности, рассчитайте наблюдаемые вероятности, с которыми выпадают значения при бросании каждого из трех игральных кубиков.\nСопоставьте результаты и определите, какой кубик является честным, какой — нечестным, а какой — невозможным.\n\n\n\n\nЧто надо сделать?\n\n\nЗагрузить файл с симуляциями с помощью кода load(url(\"https://github.com/angelgardt/wlm2023/raw/master/data/hw6/dice.RData\"))\nСчитая, что честный кубик тот, на котором выпадение каждого числа очков равновероятно, рассчитайте ожидаемые вероятности выпадения каждой грани для восьмигранного кубика.\nИспользуя загруженные функции, проведите достаточно большое количество испытаний каждого кубика — пример использования функции для 100 бросаний первого кубика: dice1(100).\nПостройте таблицу наблюдаемых частот для каждого кубика и проверьте, совпадают ли полученные результаты с рассчетом классической вероятности.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что вы ввели тольно номера кубиков, то есть ваш ответ соответствует формату 1,2,3, а не dice1,dice2,dice3\nПроверьте, что вы провели достаточное количество испытаний, чтобы получить точные оценки вероятностей.\n\n\n\n\n\n\n#2\n\n\nРассчитайте математическое ожидание случайной величины, имеющей следующую функцию вероятности:\n\n\n\n\\(x\\)\n\\(0\\)\n\\(2\\)\n\\(3\\)\n\\(6\\)\n\n\n\n\n\\(\\mathbb{P}(X=x)\\)\n\\(0.3\\)\n\\(0.4\\)\n\\(0.2\\)\n\\(0.1\\)\n\n\n\nОтсюда можно скачать таблицу в формате CSV.\n\n\n\nВ качестве ответа для самопроверки введите получившееся значение математического ожидания.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nЗагрузите таблицу, задающую функцию вероятности случайной величины.\nВ таблице есть две колонки: x — значение случайной величины, p — вероятность, с которой случайная величина принимает данное значение.\nИспользуя формулу математического ожидания для дискретной случайной величины, рассчитайте математическое ожидание данной случайной величины.\n\n\n\n\nЧто надо сделать?\n\n\nЗагрузить таблицу, задающую функцию вероятности случайной величины, с помощью функции read_csv() или read.csv().\nВ таблице есть две колонки: x — значение случайной величины, p — вероятность, с которой случайная величина принимает данное значение.\nМатематическое ожидание дискретной случайной величины определяется следующим образом:\n\n\\[\n\\mathbb{E}(X) = \\sum_{i=1}^{n} x_ip_i\n\\] * Используя эту формулу и знания о работе с датафреймами, вычислите математическое ожидание.\n\n\n\nОтвет неверный\n\n\nПроверьте рассчеты — в результате вычислений должно получатся целое число.\n\n\n\n\n\n\n#3\n\n\nДля случайной величины из предыдущего задания рассчитайте её дисперсию.\n\n\n\nВ качестве ответа для самопроверки введите получившееся значение дисперсии.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nДобавьте в загруженную таблицу новую колонку, необходимую для расчета дисперсии.\nИспользуя формулу дисперсии для дискретной случайной величины, рассчитайте дисперсию данной случайной величины.\n\n\n\n\nЧто надо сделать?\n\n\nДисперсия случайной величины определяется следующим образом:\n\n\\[\n\\text{var}(X) = \\mathbb{E}(X^2) - \\big(\\mathbb{E}(X)\\big)^2\n\\]\n\nНеобходимо рассчитать значения квадрата случайной величины на основе данных в загруженной таблицы значений x\nИспользуя вероятности p и значения из добавленной колонки, рассчитать математическое ожидание квадрата случайной величины.\nПо формуле дисперсии случайной величины рассчитать дисперсию данной случайной величины.\n\n\n\n\nОтвет неверный\n\n\nПроверьте рассчеты — в результате вычислений должно получатся целое число.\n\n\n\n\n\n\n#4\n\n\nДанные некоторого эксперимента собираются на трёх различных компьютерах, никак не взаимодействующих друг с другом. Вероятность того, что при записи данных на первом компьютере случится ошибка равна 0.2, на втором — 0.1, на третьем — 0.15.\n\nКакова вероятность, что при обработке всех данных эксперимента будут обнаружены битые (содержащие ошибки записи) данные со всех трех компьютеров?\nВ течение сбора данных эксперимента на первом компьютере было записано 30 файлов, на втором — 20, на третьем — 35. Сколько битых (содержащих ошибки записи) файлов ожидается к моменту обработки данных?\n\nСчитайте, что наличие ошибок записи зависит только от компьютера, на котором проводится эксперимент. Обработка данных начинается после сбора всех данных эксперимента.\n\n\n\nДля самопроверки в поле ответа введите два числа, разделенные запятой. Первое число — ответ на пункт а, округленный до тысячных, второе — ответ на пункт b, округленный до целого. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nОпределите, с каким событиями вы работете — зависимыми или независимыми.\nВыясните, что представляет собой вероятность, которая должна быть подсчитать в пункте а.\nВспомните, как для таких событий ведет себя вероятность, которую вам необходимо вычислить.\n\n\n\n\nЧто надо сделать?\n\n\nСобытием в данной ситуации является ошибка в записи данных. Так как компьютеры не взаимодействуют друг с другом, то события можно считать независимыми.\nПо условию нас интересует вероятность пересечения трех независимых событий. Необходимо вычислить её по соответствующей формуле.\nТак как статистическая интерпретация вероятности говорит нам, что \\(P(A) \\approx \\frac{n(A)}{n}\\), то можно вычислить долю событий, в которых реализовалось некоторое событие — это и требуется в пункте b.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что во вводимом ответе одно число отделено от другого запятой.\nПроверьте, что в качестве десятичного разделителя используется точка.\nПроверьте, что первое число (пункт a) округлено до тысячных, а второе (пункт b) — до целого.\n\n\n\n\n\n\n#5\n\n\nТри психолога независимо друг от друга выполняют тестовое задание на позицию продуктового аналитика. У них разная степень прошаренности в статистике, поэтому вероятности того, что они выполнят тестовое задание правильно равны 0.8, 0.7 и 0.6 соответственно.\n\nКакова вероятность, что никто из кандидатов не выполнит правильно тестовое задание?\nКакова вероятность, что хотя бы один из кандидатов выполнит правильно тестовое задание?\n\n\n\n\nДля самопроверки в поле ответа введите два числа, разделенные запятой. Первое число — ответ на пункт а, второе — ответ на пункт b. Оба значения округлите до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nОпределите, как соотносятся события, вероятности которых даны в задании, и события, о которых спрашивается в пункте а.\nВычислите эту вероятность, учитывая допущение в связанности событий друг с другом, указанное в задании.\nОпределите, как соотносится событие, вероятность которого необходимо вычислить в пункте b, с событием, вероятность которого вы вычислили в пункте a.\n\n\n\n\nЧто надо сделать?\n\n\nВ пункте a спрашивается про вероятность пересечения событий, обратных к тем, вероятности которых известны из задания. Необходимо сначала расчитать вероятности события \\(A_i\\), зная вероятности событий \\(\\bar A_i\\).\nПо условию интересующие нас события никак не влияют друг на друга, а интересует нас вероятность пересечения событий \\(\\bar A_i\\). По соответствующей формуле необходимо вылислить искомую вероятность.\nСобытие, о котором говорится в пункте b, является обратным к событию, вероятность которого рассчитана в пункте a. Действовать в этом случае нужно аналогично первому шагу пункта a.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что во вводимом ответе одно число отделено от другого запятой.\nПроверьте, что в качестве десятичного разделителя используется точка.\nПроверьте, что обы числа округлены до тысячных.\n\n\n\n\n\n\n#6\n\n\nНа специальности 37.03.01 «Психология» в бакалавриате некоего вуза учится 1500 студентов: 520 на первом курсе, 480 на втором и 315 на третьем. Вероятности того, что студент первого, второго, третьего и четвертого курса получил при освоении курса статистики «отлично», равны соответствено 0.6, 0.8, 0.7 и 0.65. В курилке мы случайным образом завели беседу с одним из студентов-психологов. Какова вероятность, что у него в зачетке «отлично» по статистике?\n\n\n\nДля самопроверки в поле ответа введите получившееся значение, округленное до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nРассчитайте недостающее количество на основе входных данных.\nПользуясь статистическим подходом к вероятности, рассчитайте вероятность принадлежности студента к определенному курсу.\nИнтересующее нас событие — отлично в зачетке студента. Рассчитайте полную вероятность этого события.\n\n\n\n\nЧто надо сделать?\n\n\nДля проведения расчетов нам недостает количества студентов, обучающихся на четвертом курсе. Сперва вычислите его.\nЗатем определите вероятность, с которой случайный студент принадлежит к определенному курсу, пользуясь статистическим подходом к вероятности (\\(P(A) = \\frac{n(A)}{n}\\)).\nДалее по формуле полной вероятности \\(P(A) = P(A|H_1)P(H_1) + P(A|H_2)P(H_2) + P(A|H_3)P(H_3) + P(A|H_4)P(H_4)\\), вычислите вероятность интересующего нас события. Условные вероятности заданы условием задания.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что в качестве десятичного разделителя используется точка.\nПроверьте, что значение округлено до тысячных.\nПроверьте вычисления — промежуточные результаты округлять не нужно.\n\n\n\n\n\n\n#7\n\n\nРоссийский ПЦР-тест на COVID-19 SARS-CoV-2, с помощью которого проводится экспресс-анализ для выявления коронавирусной инфекции, обладает 98% чувствительностью и 98% специфичностью. Будем считать, что в России проживает [согласно грубым оценкам] 146 700 000 человек, из которых в среднем 1 550 000 заражено COVID-19. Вы сдали тест SARS-CoV-2 на коронавирус, который показал положительный результат. Какова вероятность, что вы действительно заражены коронавирусной инфекцией?\n\n\n\n\n\n\nЧувствительность и специфичность\n\n\n\n\nЧувствительность клинического теста показывает вероятность того, что больной субъект будет идентифицирован как больной.\nСпецифичность клинического теста показывает вероятность того, что здоровый субъект будет идентифицирован как здоровый.\n\nПодробнее можно почитать тут.\n\n\n\n\n\nДля самопроверки в поле ответа введите получившееся значение, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nЗадайте условные обозначения для событий, рассматриваемых в задаче, и той, которую необходимо найти.\nЗапишите формулу, по которой вычисляется искомая вероятность.\nВыясните, каких элементов формулы не хватает для расчета.\nОдна из вероятностей выясчисляется как вероятность обратного к событию, определяетого чувствительностью или специфичностью.\n\n\n\n\nЧто надо сделать?\n\n\nОпределим события следующим образом: ILL — болен, HEALTH — здоров, plus — положительный рзультат ПЦР-теста, minus — отрицательный результат ПЦР-теста. Тогда необходимо найти вероятность \\(P(\\text{ILL}|\\text{plus})\\).\nИзвестны из условия вероятности \\(P(\\text{plus}|\\text{ILL})\\) и \\(P(\\text{minus}|\\text{HEALTH})\\)\nВычисляемы из условия вероятности \\(P(\\text{ILL})\\), \\(P(\\text{HEALTH})\\) и \\(P(\\text{plus}|\\text{HEALTH})\\).\nЗапишите для вероятности \\(P(\\text{ILL}|\\text{plus})\\) формулу Байеса, если общий вид этой формулы таков:\n\n\\[\nP(B|A) = \\frac{P(A|B) \\cdot P(B)}{P(A|B) \\cdot P(B) + P(A|\\bar B) \\cdot P(\\bar B)}\n\\]\n\nВычислите необходимые элементы этой формулы и сам ответ по формуле.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что в качестве десятичного разделителя используется точка.\nПроверьте, округлен ли ответ до сотых по математическим правилам.\nПроверьте вычисления: чувствительность и/или специфичность не используются в расчете непосредственно.\n\n\n\n\n\n\n#8\n\n\nКакова вероятность, что сотрудник случайно пройдет квалификационный тест, который включает в себя 30 тестовых вопросов с пятью вариантами ответа, если в каждом вопросе только один правильный ответ, а для прохождения теста необходимо набрать минимум 25 правильных ответов? Считайте, что тест хорошо сконструирован, поэтому все альтернативы в каждом вопросе равнозначны, а вопросы не связаны друг с другом.\n\n\n\nДля самопроверки в поле ответа введите получившееся значение в научном формате записи числа (scientific notation).\nПример, как выглядит научный формат в жизни: \\(2.3\\times10^{-12}\\).\nПример, как это число вводить в поле ответа: 2.3*10^-12.\nМантиссу (число слева от знака умножения) округлите до сотых. В качестве десятичного разделителя используйте точку. Подробнее о научном формате записи чисел тут.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nОпределите, как вычисляется вероятность события сотрудник случайно отвечает ровно на k вопросов правильно.\nДополните формулу так, чтобы вычислялась вероятность события сотрудник случайно отвечает ровно на k любых вопросов правильно.\nУчтите, что в случае, если набрано быллов больше, чем 25, тест также будет пройденным.\nСобрав все предыдущие пункты, вычислите искомую вероятность.\n\n\n\n\nЧто надо сделать?\n\n\nОтветы на серию вопросов теста являются серией испытаний Бернулли, описываемой формулой \\(P(X = k) = C_n^k p^k(1-p)^{n-k}\\), где \\(P(X = k)\\) — вероятность того, что на любые \\(k\\) вопросов будут даны правильные ответы, \\(n\\) — общее количество вопросов, \\(p\\) — вероятность случайно дать правильный ответ на один вопрос.\nНеобходимо суммировать результаты подсчетов по этой формуле, так как в случае \\(25 \\leq k \\leq 30\\) тест считается пройденным.\n\n\n\n\nОтвет неверный\n\n\nПроверьте округление резульатата — округлить мантиссу (число слева от знака умножения) нужно до сотых по математическим правилам.\nПроверьте формат ввода: умножение записывается звездочкой (*), возведение в степень крышечкой (^), десятичный разделитель — точка.\nВывод R формата 2.3e-12 означает 2.3*10^-12.\n\n\n\n\n\n\n#9\n\n\nИзвестно, что время реакции (\\(X\\), секунды) в некотором эксперименте подчиняется следующему распределению:\n\n\n\n\n\n\n\n\n\nЭто гамма-распределение (dgamma()) с параметрами shape = 2 и rate = 1.\n\nНайдите вероятность, что время реакции в случайной пробе будет равно 8.28 секунды.\nНайдите вероятность, что время реакции в случайной пробе будет находится в пределах от 2 до 6 секунд.\n\n\n\n\nДля самопроверки в поле ответа введите два числа, разделенные запятой. Первое число — ответ на пункт а, второе — ответ на пункт b. Оба значения округлите до сотых. В качестве десятичного разделителя используйте точку.\nЕсли в ответе получается целое число, то введите его в формате 2.00.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\nВспомните особенности поведения непрерывных случайных величин.\nВспомните, где находится вероятность на графике плотности распределения.\nСоотнесите визуальное представление с математическим.\n\n\n\n\nЧто надо сделать?\n\n\nПроанализировать вопрос пункта a — о какой вероятности в нем спрашивается? Как в случае непрерывных случайных величин определена такая вероятность? какое значение они принимает?\nДля определения вероятности попадания значения непрерывной случайной величины в определенный интервал необходимо проинтегрировать функцию плотности вероятности в заданных границах. Поможет функция integrate().\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что числа разделены запятой.\nПроверьте, что в качестве десятичного разделителя используется точка.\nПроверьте, что значния округлены до сотых.\nПроверьте, что целочисленные значения, если они есть в ответе, введны в формате x.00\nПроверьте вычисления — задание пределов интегрирования.\n\n\n\n\n\n\n#10\n\n\nВизуализируйте функцию плотности вероятности нормального распределения с параметрами \\(\\mu = 8.2\\) и \\(\\sigma^2 = 37.21\\).\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля визуализации плотности распределния в ggplot2 есть функция geom_function().\nЕё необходимо передать в аргумент fun функцию, которую необходимо нарисовать, а в аргумент args именованный список параметров, которые задают функцию.\nВозможно, потредуется задать диапазон значений оси x с помощью функции xlim().\nТакже есть способ визуализации через генерацию последовательсти значений x и расчета для них значений функции dnorm(). В этом случае используется geom_line().",
    "crumbs": [
      "HW6 // Случайный эксперимент. Случайные величины"
    ]
  },
  {
    "objectID": "hw7.html",
    "href": "hw7.html",
    "title": "HW7 // Оценивание параметров в практике статистического анализа. Тестирование статистических гипотез",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW7 // Оценивание параметров в практике статистического анализа. Тестирование статистических гипотез"
    ]
  },
  {
    "objectID": "hw7.html#hw7_main",
    "href": "hw7.html#hw7_main",
    "title": "HW7 // Оценивание параметров в практике статистического анализа. Тестирование статистических гипотез",
    "section": "",
    "text": "#1\n\n\nНам вновь потребуются сгенерированные данные.\nСгенерируйте 1000 независимых выборок по 100 наблюдений из генеральной совокупности, в которой некоторый признак подчиняется распределению хи-квадрат (rchisq()) с параметром 3 (df = 3) — \\(X \\sim \\chi^2(3)\\).\nВ качестве зерна датчика случайных чисел используйте 333 (set.seed(333)).\n\n\n\n\n\n\n\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nТребуется сгенерировать матрицу, размером 100×1000, в каждой колонке которой будут содержаться наблюдения одной выборки.\nТак как выборки независимы, сгенерировать 1000 выборок по 100 наблюдений это то же самое, что сгенерировать одну большую выборку из 100 000 наблюдений, а затем сложить в матрицу по колонкам.\nСгенерировать выборку поможет функция rchisq(), которая работает аналогично хорошо знакомой rnorm(), только принимает в себя один параметр df (помимо количества наблюдений, которые нужно сгенерировать).\nПо заданию df = 3, именно такое значение параметра и нужно передать в функцию.\nСложить сгенерированный вектор в матрицу поможет функция matrix().\n\n\n\n\n\n#2\n\n\nНа практике мы посмотрели, что центральная предельная теорема (ЦПТ) выполняется в случае с симметричным распределением, а именно с нормальным. Однако сама по себе ЦПТ не оговаривает какие-либо специальные требования к форме исходного распределения. Покажите с помощью симуляции, что распределение выборочных средних большого числа ассиметричных случайных величин будет стремиться к нормальному распределению.\nИспользуйте матрицу sim1.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nСгенерированная в предыдущем задании матрица содержит 1000 выборок, на каждой из которых необходимо рассчитать среднее значение.\nДля того, чтобы выполнить какую-либо функцию на каждой из колонок, можно воспользоваться функцией apply().\nФункция apply() вернет вектор из средних значений, который дальше необходимо визуализировать средствами пакета ggplot2.\n\n\n\n\n\n#3\n\n\nМы также увидели на практике, что среднее арифметическое является несмещенной оценкой математического ожидания. Ну, в какой-то мере это был ожидаемый результат — распределение всё-таки у нас было симметричное. Не вполне ясно, будет ли сохранться несмещенность оценки, если наше распределение в генеральной совокупности теперь асимметрично.\nПроверьте, является ли среднее арифметическое несмещенной оценкой математического ожидания в случае асимметричного распределения. Математическое ожидание распределения \\(\\chi^2(3)\\) равно 3: \\(\\mathbb E \\big( \\chi^2(3) \\big) = 3\\). Используйте матрицу sim1.\nСделайте вывод о (не)смещенности оценки.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЗа основу возьмите график из предыдущего задания — ровно он нам и нужен.\nНа график необходимо добавить две линии: одна будет обозначать генеральное среднее, другая — среднее выборочных средних.\nОбе линии визализируются с помощью geom_vline(), однако в первом случае функция aes() не используется, а во втором — используется, так как среднее средних рассчитается на основе данных.\nГенеральное среднее в случае распределение хи-квадрат будет совпадать с параметром df.\nЕсли линии находятся близко друг к другу, то оценку можно считать несмещенной. Если оценка значительно отклоняется от параметра генеральной совокупности, то оценка является смещенной.\n\n\n\n\n\n#4\n\n\nВопрос про состоятельность также возникает в случае асимметричного распределения. Потребуется другая структура данных, чтобы проверить сохранение этого свойства оценки.\nСгенерируйте 1000 выборок, объемом от 1 до 1000 наблюдений, из генеральной совокупности, в которой некоторый признак подчиняется распределению хи-квадрат (rchisq()) с параметром 3 (df = 3) — \\(X \\sim \\chi^2(3)\\). Результаты генерации сохраните в список sim2.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nВ случае проверки оценки на состоятельность необходимы выборки разного объема, поэтому сложить их в матрицу будет сложнее — проще использовать список.\nСоздайте пустой список sim2, а затем с помощью цикла сложите в него выборки, объемом от 1 до 1000 наблюдений, из того же распределения, что и в первом задании.\nВ функции rchisq() один из параметров теперь будет меняться — в качестве этого параметра необходимо передать итератор (обычно i) из условия цикла.\n\n\n\n\n\n#5\n\n\nНа сгенерированных в предыдущем задании данных проверьте, является ли выборочная дисперсия s^2 (var()) состоятельной оценкой дисперсии генеральной совокупности в случае асимметричного распределения. Дисперсия распределения \\(\\chi^2(3)\\) равна 6 — \\(\\mathbb D \\big( \\chi^2 (3) \\big) = 6\\).\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nНа каждом элементе списка sim2 необходимо рассчитать дисперсию с помощью функции var().\nПрогнать функцию по всем элементам списка поможет функция map().\nРезультатом функции map() является список, который необходимо прекратить в вектор, чтобы с ним дальше было удобно работать на визуализации. Здесь пригодится функция unlist().\nПри построении визуализации нужно отобразить, как меняется оценка дисперсии с ростом выборки, а также добавить горзионтальную линию, обозначающую дисперсию генеральной совокупности, чтобы из графика было видно, куда сходится оценка.\nДисперсия генеральной совокупности в случае распределения хи-квадрат равна \\(2 \\times \\text{df}\\), то есть в нашем случае 6.\n\n\n\n\n\n#6\n\n\nНапишите функцию ci для вычисления 90% доверительного интервала для среднего. Считайте, что мы работем с выборокой большого объема (порядка 100 наблюдений).\nПороговыми значениями стандартного нормального распределения считайте следующие: \\(z_{0.05} = -1.64\\), \\(z_{0.95} = 1.64\\).\n\n\n\nДля самопроверки в поле ответа введите доверительный интервал для среднего первой выборки из симуляции sim1 в формате lower,upper. Значения округлите до сотых. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЛогика расчета границ доверительного интервала всегда одна и та же — \\([\\text{se}_X \\cdot z_q + \\bar X, \\text{se}_X \\cdot z_{1-q} + \\bar X]\\).\nЕсли в случае 95% доверительного интервала \\(z_q = -1.96\\), а \\(z_{1-q} = 1.96\\), то в случае 90% доверительного интервала — \\(z_q = -1.64\\), а \\(z_{1-q} = 1.64\\).\nТаким образом, можно просто изменить значения, умножаемые на стандартрую ошибку, в коде из практики.\nЕсли в самопроверке ответ неверный, то проверьте округление (должно быть до сотых) и формат ввода (значения разделяются запятой, десятичный разделитель — точка).\n\n\n\n\n\n#7\n\n\n\nПостройте визуализацию, выражающую статистически корректную интерпретацию 90% доверительного интервала для среднего. Используйте матрицу sim1.\nРассчитайте долю доверительных интервалов симуляции sim1, в границы которых попало значение параметра генеральной совокупности.\n\n\n\n\nДля самопроверки в поле ответа введите значение, получившееся в пункте b. Значение округлите до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЧтобы визуализировать статистически корректную интерпретацию доверительного интервала, необходимо отобразить все доверительные интервалы, полученные в симуляции (1000 штук), и генеральное среднее (удобнее всего в виде линии).\nЦветом необходимо обозначить, попало ли генеральное среднее в конкретный доверительный интервал, или нет. Для этого в данных нужно создать колонку (например, логического типа), в которой для каждого доверительного интервала будет указано, принадлежит ли ему значение среднего генеральной совокупности, или не принадлежит.\nПо этой колонке можно рассчитать и долю доверительных интервалов, содержащих генеральное среднее, с помощью функции mean() (если колонка была типа logical).\nСами данные для визуализации получаются применением функции ci, созданной в предыдущем задании, к матрице sim1 с помощью функции apply().\nРезультатом работы функции apply() будет матрица 3×1000, которую необходимо привести к датафрейму (тибблу), предварительно транспонировав фунцией t() — так будет удобнее с ней работать.\nТакже для удобства визуализации можно создать в получившемся тиббле колонку с номером выборки в симуляции.\nЕсли в самопроверке ответ неверный, то проверьте округление (должно быть до тысячных) и формат ввода (десятичный разделитель — точка).\n\n\n\n\n\n#8\n\n\n\nПостройте визуализацию, показывающую графически смысл capture percentage. Считайте, что мы работаем с 1000-ой выборкой из симуляции sim1 — capture percentage именно для этого доверительного интервала нас интересует.\nРассчитайте capture percentage для этого доверительного интервала.\n\n\n\n\nДля самопроверки в поле ответа введите значение, получившееся в пункте b. Значение округлите до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЧтобы визуализировать capture percentage, аналогично предыдущему заданию, необходимо отобразить все доверительные интервалы, полученные в симуляции (1000 штук). Генеральное среднее также можно отобразить (удобнее всего в виде линии).\nЦветом необходимо обозначить те средние (с доверительными интервалами), которые попали в доверительный интервал для какого-либо отдельного среднего.\nАНалогично предыдущему заданию, необходимо создать колонку в данных визуализации. По заданию мы работаем с доверительным интервалом 1000-ой выборки симуляции, поэтому при создании колонки (например, логического типа) необходимо проверить, попадают ли средние все выборок в доверительных интервал среднего 1000-ой выборки.\nПо этой колонке можно рассчитать и capture percentage рассматриваемого доверительного интервала, с помощью функции mean() (если колонка была типа logical).\nСами данные для визуализации получаются применением функции ci, созданной в предыдущем задании, к матрице sim1 с помощью функции apply(), то есть абсолютно аналогично предыдущему заданию.\nРезультатом работы функции apply() будет матрица 3×1000, которую необходимо привести к датафрейму (тибблу), предварительно транспонировав фунцией t() — так будет удобнее с ней работать.\nТакже для удобства визуализации можно создать в получившемся тиббле колонку с номером выборки в симуляции.\nЕсли в самопроверке ответ неверный, то проверьте округление (должно быть до тысячных) и формат ввода (десятичный разделитель — точка).\n\n\n\n\n\n#9\n\n\nСогласно формуле расчета стандартной ошибки среднего \\(\\text{se}_X = \\frac{\\text{sd}_X}{\\sqrt{n}}\\), стандартная ошибка должна уменьшаться с ростом объема выборки. Соответственно, границы доверительных интервалов также должны становиться более узкими.\nИспользуя симуляцию sim2 покажите графически, что:\n\nстандартная ошибка среднего уменьшается с ростом объема выборки\nдоверительные интервалы становятся более узкими с ростом объема выборки\n\nДля расчета доверительного интервала используйте функцию ci, написанную в задании 6. Для визуализации доверительных интервало в этом задании лучше подойдет geom_errorbar().\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЧтобы отобразить искомые закономерности, нам необходимо построить графики, на которых по оси x будет располагаться объем выборки (он же будет её порядковым номером — такова структура списка sim2), а по оси y — стандартная ошибка или доверительный интервал.\nАналогично симуляции для проверки состоятельности оценки, необходимо выполнить функции se() и ci() соответственно на элементах списка sim2. Вновь пригодится функция map().\nВ случае с функцией se() можно написать такую функцию отдельно, а можно воспользоваться анонимными функциями.\nРезультат работы функции map() необходимо преобразовать к датафрейму (тибблу) — это будет данными для визуализации.\nДалее построить соответствующие графики — для стандартной ошибки подойдет geom_point(), а для доверительных интервалов — geom_errorbar(), так как он не отображает среднее и визуализация будет менее нагружена.\n\n\n\n\n\n#10\n\n\nСогласно всё той же формуле расчета стандартной ошибки среднего \\(\\text{se}_X = \\frac{\\text{sd}_X}{\\sqrt{n}}\\), она должна расти с увеличением дисперсии. Соответственно, границы доверительных интервалов также должны становиться более широкими.\n\nСгенерируйте 200 выборок по 100 наблюдений из генеральной совокупности, в которой некоторый признак подчиняется распределению хи-квадрат (rchisq(n, df = k)) \\(X \\sim \\chi^2(k)\\), а параметр \\(k\\) меняется от 1 до 200. Сохраните результаты в список sim3. В качестве зерна датчика случайных чисел используйте значение 555 (set.seed(555)).\n\nИспользуя полученную симуляцию sim3 покажите графически, что:\n\nстандартная ошибка растет с увеличением дисперсии выборки\nдоверительные интервалы становятся более широкими с увеличением дисперсии выборки\n\nДля расчета доверительного интервала используйте функцию ci, написанную в задании 6. Для визуализации доверительных интервало в этом задании лучше подойдет geom_errorbar().\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЧтобы отобразить искомые закономерности, нам необходимо построить графики, на которых по оси x будет располагаться значение параметра распределения хи-квадрат (он же будет её порядковым номером, а также будет связан с дисперсией — таково устройство распределения хи-квадрат), а по оси y — стандартная ошибка или доверительный интервал.\nСимуляция sim3 для этого задания создается аналогично симуляции sim2, только теперь варьироваться будет не количество наблюдений, а параметр распределения (df) — именно ему нужно передать итератора (обычно i) из условия цикла.\nДалее необходимо выполнить функции se() и ci() соответственно на элементах списка sim3. Вновь пригодится функция map().\nВ случае с функцией se() можно написать такую функцию отдельно, а можно воспользоваться анонимными функциями.\nРезультат работы функции map() необходимо преобразовать к датафрейму (тибблу) аналогично предыдущему заданию — это будет данными для визуализации.\nДалее построить соответствующие графики — для стандартной ошибки подойдет geom_point(), а для доверительных интервалов — geom_errorbar(), так как он не отображает среднее и визуализация будет менее нагружена.",
    "crumbs": [
      "HW7 // Оценивание параметров в практике статистического анализа. Тестирование статистических гипотез"
    ]
  },
  {
    "objectID": "hw8.html",
    "href": "hw8.html",
    "title": "HW8 // Описательные статистики. Корреляционный анализ",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW8 // Описательные статистики. Корреляционный анализ"
    ]
  },
  {
    "objectID": "hw8.html#hw8_main",
    "href": "hw8.html#hw8_main",
    "title": "HW8 // Описательные статистики. Корреляционный анализ",
    "section": "",
    "text": "#1\n\n\nЗагрузите данные. Проверьте их структуру. При необходимости скорректируйте типы и названия переменных.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nИсследуйте данные.\n\nПроверьте, есть ли в данных пропущенные значения.\nПосмотрите, сбалансирована ли выборка по полу.\nПосмотрите, сбалансирована ли выборка по рациону.\nПосмотрите, сбалансирована ли выборка по прохождению подготовительного теста.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nПроверить наличие пропущенных значений можно с помощью функций apply(), is.na() и sum().\nПроверить сбалансированность выборки по категориальным переменным можно построив таблицу частот с помощью функции table().\n\n\n\n\n\n#3\n\n\nПостройте разведочные визуализации для переменных math score, reading score и writing score.\n\nВизуализируйте распределения этих переменных.\nДобавьте на график с распределениям разбиение по прохождению курса подготовки к тестированию (test preparation course).\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля визуализации распределения в пункте a достаточно построить гистограммы по указанным переменным.\nЧтобы упростить выполнение пункта b, стоит расположить гистограммы на одном графике.\nЧтобы разбить добавить разбиение распределений по переменной, необходимо фасетировать график по этой переменной.\n\n\n\n\n\n#4\n\n\n\nРассчитайте описательные статистики по переменным math score, reading score, writing score.\nДобавьте к расчету описательных статистик разбиение по переменной test preparation course.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nРассчитать описательные статистики можно с помощью функции summarise() или использовать функцию describe() из пакета psych.\nДобавить к подсчету описательных статистик разбиение по какой-либо переменной можно с помощью функции group_by() или с помощью аргумента .by функции summarise(), однако можно использовать и функцию describeBy() из пакета psych.\n\n\n\n\n\n#5\n\n\nПостройте корреляционную матрицу по переменным math score, reading score, writing score.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#6\n\n\nЭкспортируйте получившуюся в предыдущем задании матрицу как таблицу, оформленную по стандартам APA.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nДля экcпорта красивых форматированных таблиц написан пакет apaTables. В ней есть функция apa.cor.table(), которая позволяет форматировать и экспортировать корреляционную матрицу.\n\n\n\n\n#7\n\n\nВизуализируйте корреляционную матрицу, получившуюся в задании 5.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nКорреляционную матрицу легко визуализировать с помощью функции ggcorrplot() из пакета ggcorrplot.\nТак как ggcorrplot является расширением ggplot2, то экспортировать графика можно с помощью функции ggsave().\n\n\n\n\n\n#8\n\n\nВ корреляционной матрице мы наблюдаем крайне высокую корреляцию между баллами по чтению и правописанию, что вполне логично. Давайте удостоверимся в том, что корреляция статистически значима.\nПротестируйте гипотезу о статистической значимости коэффициента корреляции между баллами по чтению и правописанию.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#9\n\n\nОформите результаты корреляционного анализа в формате APA.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nЧтобы форматировать результаты корреляционного анализа в APA-формате, написан пакет report, в котором живет функция report(). В неё необходимо передать объект с результатам корреляционного анализа.\n\n\n\n\n#10\n\n\nВ данном случае мы столкнулись с очень высокой корреляцией, однако, увы, это не всегда так. Рассчитайте объем выборки, требуемый для достижения достаточной статистической мощности, если мы ожидаем в исследовании корреляцию порядка 0.2.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nРассчетом объема выборки занимается пакет pwr, в котором есть функция pwr.r.test().",
    "crumbs": [
      "HW8 // Описательные статистики. Корреляционный анализ"
    ]
  },
  {
    "objectID": "hw8.html#hw8_add",
    "href": "hw8.html#hw8_add",
    "title": "HW8 // Описательные статистики. Корреляционный анализ",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n#1\n\n\nВыше мы проверяли достаточно очевидные гипотезы. Однако данные позволяют протестировать и более веселые.\nПроверьте, если ли связь между тем, какой рацион у учащегося, и тем, завершил ли он курс по подготовке к тестированию или нет.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nДля того, чтобы проверить гипотезу о связи между двумя категориальными переменными, необходимо использовать критерий независимости Пирсона \\(\\chi^2\\). Реализовать этот статистический тест можно с помощью функции chisq.test().\n\n\n\n\n#2\n\n\nРассчитайте корреляцию между переменными из предыдущего задания.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nПривести статистику \\(\\chi^2\\) к значению корреляции можно по формуле \\(\\varphi = \\sqrt{\\frac{\\chi^2}{N}}\\). Полученное значение будет \\(\\phi\\)-коэффициентом, который является коэффициентом корреляции для категориальных переменных.\n\n\n\n\n#3\n\n\nВизуализируйте результат, получившися в первом дополнительном задании.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nДля визуализации связи между двумя категориальными переменными используется тип графика mosaic plot. Построить его можно с помощью функции geom_mosaic(). Для этого необходимо установить и полдключить пакет ggmosaic.\n\n\n\n\n#4\n\n\nИнтересно было бы посмотреть, есть ли связь между завершением подготовительного курса и баллом по математике.\nПротестируйте гипотезу об отсутствии связи между переменными math score и test preparation course.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nВизуализируйте результат, получившися в предыдущем задании.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW8 // Описательные статистики. Корреляционный анализ"
    ]
  },
  {
    "objectID": "hw9.html",
    "href": "hw9.html",
    "title": "HW9 // Простая линейная регрессия. Множественная линейная регрессия",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW9 // Простая линейная регрессия. Множественная линейная регрессия"
    ]
  },
  {
    "objectID": "hw9.html#hw9_main",
    "href": "hw9.html#hw9_main",
    "title": "HW9 // Простая линейная регрессия. Множественная линейная регрессия",
    "section": "",
    "text": "#1\n\n\nСегодня в нашем распоряжении данные о продаже домов. В данных достаточно много переменных, кодбук можно найти здесь.\nЗагрузите данные и сохраните их в объект houses. Изучите их структуру. Проверьте наличие пропущенных значений в столбцах.\n\n\n\nДля самопроверки в поле ответа введите количество пропущенных значений в переменной Alley. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nВ данных есть переменная SalePrice — цена участка. Поизучаем, какие характеристики участка оказывают влияние1 на его цену.\nВ данные также есть переменная LotArea — площадь участка. Кажется, разумно предположить, что площадь участка влияет на его стоимость. Проверим данную гипотезу.\n\nПостройте регрессионную модель, в которой целевой переменной будет цена участка, а предиктором — его площадь.\nПроинтерпретируйте результаты моделирования.\n\n\n\n\nДля самопроверки в поле ответа введите коэффициент детерминации (Multiple R-squared) построенной модели. Значение округлите до сотых. В качестве десятичного разделителя используйте точку. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак построить модель?\n\n\nДля построение модели линейной регрессии используйте функцию lm()\nМодель задается первым аргументом в формульном виде y ~ x\nВторым аргументом функции необходимо передать имеющиеся данные\nСохраните модель в объект (например, model1).\n\n\n\n\nКак проинтерпретировать результаты?\n\n\nВывести статистики модели можно с помощью функции summary(), в которую необходимо передать объект, содержащий регрессионную модель.\nИнтерпретируются прежде всего следующие показатели: F-статистика (и её p-value), коэффициент детерминации и t-статистики (и их p-value).\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что значение округлено до сотых.\nПроверьте, что в качестве десятичного разделителя используется точка.\n\n\n\n\n\n\n#3\n\n\n\nПроведите графическую диагностику модели. Дайте интерпретацию полученных результатов.\nВизуализируйте модель.\n\n\n\n\nДля самопроверки в поле ответа введите количество влиятельных наблюдений, обнаруженых в ходе диагностики. Если влиятельных наблюдений нет, введите 0. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак провести диагностику?\n\n\nДля этого необходимо построить диагностически графики с помощью функции plot().\nНеобходимо проверить выполнение допущений о распределении остатков модели, их связи с предсказанными значениями целевой переменной и наличие влиятельных наблюдений.\n\n\n\n\nКак визуализировать модель?\n\nДля визуализации необходимо построить график, отображающий линейную связь между переменными модели.\n\n\n\n\n\n#4\n\n\nВ данных есть интересная переменная SalesCondition — условия продажи участка. Выдвинем следующую гипотезу: в случае стандартных условий продажи (Normal) и продажи частично достроенного дома (Partial) цена будет выше, чем в случае нестандартной продажи (Abnorml).\nОтберите необходимые наблюдения для проверки данной гипотезы.\n\n\n\nДля самопроверки в поле ответа введите количество строк в получившемся датасете.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\n\nДобавьте в имеющуюся модель еще один предиктор SaleCondition для проверки заявленной выше гипотезы. Постройте модель на отобранных в предыдущем задании данных.\nПроинтерпретируйте результаты моделирования.\n\n\n\n\nДля самопроверки в поле ответа введите коэффициент детерминации (Multiple R-squared) построенной модели. Значение округлите до сотых. В качестве десятичного разделителя используйте точку. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак построить модель?\n\n\nДля построение модели линейной регрессии используйте всё ту же функцию lm()\nМодель задается первым аргументом в формульном виде y ~ x1 + x2\nВторым аргументом функции необходимо передать имеющиеся данные\nСохраните модель в объект (например, model2).\n\n\n\n\nКак проинтерпретировать результаты?\n\n\nВывести статистики модели можно с помощью функции summary(), в которую необходимо передать объект, содержащий регрессионную модель.\nИнтерпретируются прежде всего следующие показатели: F-статистика (и её p-value), коэффициент детерминации и t-статистики (и их p-value).\nОбратите внимание на смысл коэффицинтов при переменных SaleConditionNormal и SaleConditionPartial.\n\n\n\n\nОтвет неверный\n\n\nПроверьте, что значение округлено до сотых.\nПроверьте, что в качестве десятичного разделителя используется точка.\n\n\n\n\n\n\n#6\n\n\n\nПроведите графическую диагностику модели. Дайте интерпретацию полученных результатов.\nСравните по результатам диагностики две построенные модели.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#7\n\n\nВ данных есть еще один количественные предиктор, которые потенциально может влиять на целевую переменную — это LotFrontage, длина стороны участка, которая соединена с улицей города. Выдвинем предположение, что и площадь участка LotArea, и уличная сторона LotFrontage влияют на цену участка SalePrice.\n\nПостройте модель, позволяющую проверить данную гипотезу.\nПроинтерпретируйте результаты моделирования.\n\n\n\n\nДля самопроверки в поле ответа введите значение F-статистики модели (F-statistic). Значение округлите до целого. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак построить модель?\n\n\nДля построение модели линейной регрессии используйте всё ту же функцию lm()\nСогласно гипотезе, нас интересует модель без взаимодействия.\nМодель задается первым аргументом в формульном виде y ~ x1 + x2\nВторым аргументом функции необходимо передать имеющиеся данные\nСохраните модель в объект (например, model3).\n\n\n\n\nКак проинтерпретировать результаты?\n\n\nВывести статистики модели можно с помощью функции summary(), в которую необходимо передать объект, содержащий регрессионную модель.\nИнтерпретируются прежде всего следующие показатели: F-статистика (и её p-value), коэффициент детерминации и t-статистики (и их p-value).\nОбратите внимание на смысл коэффицинтов при количественных предикторах.\n\n\n\n\nОтвет неверный\n\nПроверьте, что значение округлено до целого\n\n\n\n\n\n#8\n\n\nВ последнюю построенную модель включены два количественных предиктора. Мы не проводили подробный разведочный анализ данных, поэтому не знаем, была ли опасность мультиколлинеарности.\nПроверьте, есть ли в модели с двумя количественными предикторами проблема мультиколлинеарности.\n\n\n\nДля самопроверки в поле ответа введите да, если проблема мультиколлинеарности есть, и нет, если такой проблемы нет.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля проверки наличия мультиколлинеарности необходимо рассчитать коэффициенты вздутия дисперсии (variance inflation factor, VIF) для предикторов модели.\nДля этого можно воспользоваться функцией vif() из пакета car.\n\n\n\n\n\n#9\n\n\nДавайте совместим построенные модели. У нас есть следующие предикторы: LotArea, LotFrontage и SaleCondition (изучаем три условия — Normal, Partial и Abnorml). Нам интересно изучить, как эти предикторы влияют на цену участка SalePrice.\nВ качестве предикторов в модель должны быть включены основные эффекты предикторов LotArea, LotFrontage и SaleCondition, а также взаимодействие между LotArea и SaleCondition.\n\nПостройте модель на данных, отобранных в задании 4.\nПроинтерпретируйте результаты моделирования. с. Проведите графическую диагностику модели.\n\n\n\n\nДля самопроверки в поле ответа введите значение F-статистики модели (F-statistic). Значение округлите до целого. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#10\n\n\n\nПо результатам, полученным в задании 9, предположите, можно ли исключить из последней построенной модели взаимодействие предикторов.\n«Обновите» модель из задания 9, исключив из неё взаимодействие предикторов. с. Сравните модель со взаимодействием и модель без взаимодействия с помощью статистического теста. Проинтерпретируйте результаты.\n\n\n\n\nДля самопроверки в поле ответа введите значение F-статистики модели (F-statistic). Значение округлите до целого. Проверка игнорирует все пробелы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW9 // Простая линейная регрессия. Множественная линейная регрессия"
    ]
  },
  {
    "objectID": "hw9.html#hw9_add",
    "href": "hw9.html#hw9_add",
    "title": "HW9 // Простая линейная регрессия. Множественная линейная регрессия",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n#1\n\n\nВ задании 2 мы построили модель, в которой обнаружелись влиятельные наблюдения. Давайте посмотрим, что будет, если мы исключим эти наблюдения из выборки.\n\nИсключите влиятельные наблюдения из данных, воспользовавшись номером строки, которые представлен на диагностическом графике.\nПостройте регрессионную модель, аналогичную той, что была в задании 2, но на новых данных (без влиятельных наблюдений).\nСравните две модели. Используйте коэффициент детерминации и среднюю квадратичную ошибку.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nВ задании 5 была построена модель с количественным и категориальным предиктором без взаимодействия. Неплохо было бы её визуализировать, однако если мы воспользуемся стандартной функцией geom_smooth(method = \"lm\") из ggplot2, то получим визуализацию модели со взаимодействием. Для того, чтобы получить нужную визуализацию, надо немного поколдовать.\nа. Добавьте в датасет, на котором была построена модель из задания 5, колонку с предсказанными моделью значениями b. Визуализируйте связь между переменными модели с помошью диаграммы рассеяния с. Добавьте визуализацию предсказанных моделью значений с помощью линии\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#3\n\n\nМы построили несколько моделей в заданиях выше. Давайте выберем ту, которая наиболее хорошо описывает наши данные.\n\nВыберите критерий (критерии) для сравнения моделей — это может быть как статистический тест, так и какая-либо из метрик качества модели (её предсказательной силы).\nИспользуя выбранный критерий (критерии), из построенных моделей выберите ту, которая лучше всего описывает данные.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#4\n\n\nДля модели, выбранной в предыдущем задании, экспортируйте результаты моделирования: текстовое описание результатов и таблицу со статистиками для предикторов модели.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nМы знаем формулу для матричного вычисления коэффициент регрессионной модели:\n\\[\n\\mathbf{b} = ( \\mathbf{X}^\\top\\mathbf{X})^{-1} \\mathbf{X}^\\top\\mathbf{y}\n\\]\nДавайте проверим, что результаты вычисления по этой формуле совпадают с результатами работы функции lm(). Рассмотрим случай только с количественными предикторами.\n\nНапишите функцию reg_coef(), которая вычисляет коэффициенты модели множественной линейной регрессии с количественными предкиторами без взаимодействия. Функция должна:\n\n\nпринимать на вход:\n\nдатасет, на котором будет строится модель (например, в аргумент data)\nназвание целевой переменной (например, в аргумент y)\nвектор названия количественных предикторов (например, в аргумент X)\n\nвычислять вектор коэффициентов в соответствии с формулой\nвозвращать вектор коэффциентов\n\nУчтите, что:\n\nинтерсепт также должен быть включен в возвращаемый вектор\nданные могут содержать пропущенные значения\n\n\nПроверьте, что команды reg_coef(data = houses, y = \"SalePrice\", X = c(\"LotArea\", \"LotFrontage\")) и lm(SalePrice ~ LotArea + LotFrontage, houses) дают одинаковый результат.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW9 // Простая линейная регрессия. Множественная линейная регрессия"
    ]
  },
  {
    "objectID": "hw9.html#footnotes",
    "href": "hw9.html#footnotes",
    "title": "HW9 // Простая линейная регрессия. Множественная линейная регрессия",
    "section": "",
    "text": "Будем говорить здесь о влиянии, исходя из простого здравосмысленного соображения: кажется, что сначала существует участок со своими характеристиками, а затем, когда владельцы решают его продать, они выставляют определенную цену.↩︎",
    "crumbs": [
      "HW9 // Простая линейная регрессия. Множественная линейная регрессия"
    ]
  },
  {
    "objectID": "hw10.html",
    "href": "hw10.html",
    "title": "HW10 // Дисперсионный анализ. Ковариационный анализ",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW10 // Дисперсионный анализ. Ковариационный анализ"
    ]
  },
  {
    "objectID": "hw10.html#hw10_main",
    "href": "hw10.html#hw10_main",
    "title": "HW10 // Дисперсионный анализ. Ковариационный анализ",
    "section": "",
    "text": "Данные поведенческого эксперимента\n\n\n\nСегодня в нашем меню данные эксперимента, проведенного на благо юзабилити-индустрии.В исследовании изучалось влияние перцептивных характеристик иконок на эффективность их обнаружения. Да, снова зрительный поиск…\nВ эксперименте варьировались следующие параметры стимулов:\n\nтип стимула (type): flat — плоский, grad — содержит градиент\nтень (shadow): TRUE — есть, FALSE — нет\n\nТакже традиционно варьировалось число стимулов в пробе (setsize) — 3, 6, 9. Перед каждой пробой испытуемому предъявлялась целевая иконка. Если испытуемый нашёл целевую иконку среди всех предложенных, он нажимал (key) стрелку вправо (right), если не обнаружил — стрелку слево (left). Так как ответ давался клавишами, в дизайне исследования были предусмотрены «пробы-ловушки» (pres), в которых не было целевого стимула. Пробы, в которых целевой стимул присутствовал, обозначены как p, а пробы, в которых целевой стимул отсутствовал — a.\nВсе испытуемые проходили все экспериментальные условия. Зависимой переменной в эксперимента было время ответа испытуемого (время реакции, time).\nГлобальный вопрос к результатам эксперимента: какие факторы влияют на скорость поиска иконок?\n\n\n\n#1\n\n\n\nЗагрузите данные, проверьте их структуру.\nОтберите только корректные пробы, в которых присутствует целевой стимул.\n\n\n\n\nВ качестве ответа для самопроверки введите число строк в получившемся после отбора необходимых проб датасете.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\n\nПриведите переменную setsize к факторному типу данных и агрегируйте (усредните) данные по каждому респонденту с учетом всех экспериментальных условий.\nПроверьте, что данные эксперимента сбалансированы по количесву наблюдений в каждом сочетании условий.\n\n\n\n\nВ качестве ответа для самопроверки если данные сбалансированы, введите в поле ответа да, если не сбалансированы, введите нет.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак агрегировать данные?\n\n\n\nЧтобы получить агререгированные данные, необходимо посчитать среднее значение времени реакции каждого испытуемого в каждом сочетании экспериментальных условий.\nДля этого необходимо задать группировку датасета по экспериментальным переменным (type, shadow, setsize) и идентификатору испытуемого (id). Здесь пригодится либо функция group_by(), либо аргумент .by функции summarise().\nДалее нужно вычислить среднее (mean()) по переменной time.\n\n\n\nКак проверить сбалансированность?\n\n\n\nЧтобы выяснить, сбаласированы ли данные, необходимо посчитать количество наблюдений в каждом сочетании экспериментальных условий в агрегированных данных.\nДля этого необходимо задать группировку датасета по экспериментальным переменным (type, shadow, setsize). Здесь пригодится либо функция group_by(), либо аргумент .by функции summarise().\nДалее нужно вычислить количество наблюдений в группах (n()).\n\n\n\nОтвет неверный\n\n\n\nПроверьте группировку в агрегации данных.\nПроверьте группировку в оценке сбалансированности данных.\n\n\n\n\n\n#3\n\n\nПроведите дисперсионный анализ экспериментальных данных. В качестве факторов модели используйте переменные setsize, type и shadow. В качестве зависимой переменной используйте время реакции. Модель дисперсионного анализа должна быть согласована с экспериментальным дизайном. Проинтерпретируйте результаты. При необходимости проверите попарные сравнения (post hoc тесты).\n\n\n\nВ качетсве ответа для самопроверки в поле ниже введите значение F-статистики, полученные для фактора shadow, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКакая должна быть модель?\n\n\nВ описании данных сказано, что все испытуемые проходили все экспериментальные условия.\nЗначит, все экспериментальные переменные являются внутригрупповыми.\nСледовательно, в модели дисперсионного анализа эти переменные должны задачать within-subject эффекты.\n\n\n\n\nКакие попарные сравнения нужны?\n\n\nКакие группы наблюдений мы будем сравнивать в post hoc тестах зависит от того, что получилось в дисперсионном анализе:\n\nесли получилось значимое взаимодействие, то и в попарных сравнениях нас интересуют, прежде всего, различия между группами по сочетаниям условий.\nесли значимым получились только основные эффекты, то и в попарных сравнениях мы будем изучать различия по группам, задаваемым отдельными факторами.\n\nЕсли результаты дисперсионного анализа показывают отсутствие значимости всех факторов, то попарные сравнения бессмысленны.\n\n\n\n\nКакую поправку использовать?\n\n\nЕсли вам всё же необходимы post hoc тесты, то нельзя обойтись без поправки на множественные сравнения.\nОсновных варианта два — поправка Холма и поправко Бонферрони. Одна более мягкая, другая более жесткая.\nКакую нужно использовать, зависит от выполнения допущения о сферичности данных. Если допущение по фактору выполнено, то можно использовать более мягкую, если не выполнено — необходима более жесткая.\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#4\n\n\nВизуализируйте результаты дисперсионного анализа.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nЭкспортируйте таблицу с результатами дисперсионного анализа.\n\n\n\nОписание инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nСпособ экспорта таблицы в результатами зависит от того, с помошью какой функции вы проводили дисперсионный анализ:\n\nесли использовалась aov(), то необходима функция apa.aov.table() из пакета apaTables\nесли использовалась ezANOVA() из пакета ez, то необхоимо обратить к результатам работы функции, извлечь из них объект ANOVA и выгрузить его, например, с помощью функции write_excel_csv() (для более простого преобразования в Excel-формат далее).\n\n\n\n\n\n\n\n\n\n\n\nДанные приложения доставки\n\n\n\nТеперь немного коснемся индустрии. Из исследователя ученого мы резко преобразовались в исследователя-аналитика компании доставки продуктов. Разработчики сделали новый — по их мнению, более удобный — дизайн приложения для заказов и выкатили его для тестирования на части пользователей. Другая часть пользователей видела старый дизайн.\nУ вас есть данные за период тестирования:\n\nid — идентификатор пользователя\ngroup — группа пользователей:\n\ntest — тестовая, которая видела новый дизайн\ncontrol — контрольная, которая видела старый дизайн\n\nsegment — сегмент пользователей:\n\nlow — низкий, неактивные пользователя приложения, совершают мало заказов\nhigh — высокий, активные пользователя приложения, совершают много заказов\n\norder — количество заказов пользователя в течение периода тестирования\n\nТимлид разработчиков пришел к вам со следующим вопросом: стоит ли выкатывать новый дизайн на всех пользователей? Ответьте на вопрос, опираясь на имеющиеся данные.\n\n\n\n\n#6\n\n\n\nЗагрузите данные, проверьте их структуру.\nПроверьте сбалансированность данных по количеству наблюдений в каждом сочетании условий.\n\n\n\n\nВ качестве ответа для самопроверки если данные сбалансированы, введите в поле ответа да, если не сбалансированы, введите нет.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#7\n\n\nНа основе результатов предыдущего задания определите, какой тип сумм квадратов необходимо использовать при проверки гипотез для ответов на вопросы заказчика.\nЗадание не предполагает написание кода. В скрипте кратко изложите ход своего рассуждения и закомментируйте эти строки.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nВсего возможно три типа сумм квадратов — I, II и III.\nУ первого типа сумм квадратов есть неприятная особенность.\nИспользование второго и третьего сумм квадратов определяется сбалансированностью данных.\n\n\n\n\n\n\n#8\n\n\nПостройте линейную модель, которая позволит ответить на поставленный тимлидом разработчиков вопрос, в необходимой параметризации.\n\n\nВ качестве ответа для самопроверки в поле ниже введите значение интерсепта построенной модели, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nСпособ параметризации модели зависит от выбранного типа сумм квадратов\n\nв одном случае способ параметризации не имеет значения\nв другом необходим только определенный способ параметризации, иначе результаты тестирования гипотез будут некорректны\n\nТак как значение интерсепта модели будет зависеть от выбранного способа параметризации, ошибка при самопроверки может быть связана с неверно выбранной парамтеризацией модели.\n\n\n\n\n\n#9\n\n\nПроведите дисперсионный анализ с помощью построенной в предыдущем задании модели. Проинтерпретируйте полученные результаты.\n\n\n\nВ качетсве ответа для самопроверки в поле ниже введите значение F-статистики, полученное для фактора group, округленное до целого.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nТестирование с помощью конкретного типа сумм квадратов\n\n\nБольшинство функций дисперсионного анализа работают со вторм типом сумм квадратов.\nФункция Anova() из пакета car позволяет прописать в аргумент type, какой именно тип сумм квадратов необходимо использовать.\n\n\n\n\nОтвет неверный\n\n\nПроверьте способ параметризации модели\nПроверье используемый тип сумм квадратов\nПроверьте округление — значение необходимо округлить до целого\n\n\n\n\n\n\n#10\n\n\n\nВизуализируйте результаты анализа.\nНа основе визуализации дайте ответ на вопрос тимлида разработчиков.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW10 // Дисперсионный анализ. Ковариационный анализ"
    ]
  },
  {
    "objectID": "hw10.html#hw10_add",
    "href": "hw10.html#hw10_add",
    "title": "HW10 // Дисперсионный анализ. Ковариационный анализ",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n\n\n\n\n\nПродолжим погружать в фонетические данные\n\n\n\nНа практике мы работали с данными о гласных русского языка.\nМы изучали, как различается длительность гласных в зависимости от ступени редукции и позиции в слове. Однако редукция влияет не только длительность гласных но и на их спектральный (частотный) состав. Давайте посмотрим, различаются ли частотные характеристики отдельных гласных в зависимости от ступени редукции.\nНас будут интересовать следующие переменные:\n\nphoneme — обозначение фонемы\n\nк нередуцированным гласным относятся o, i, a, u, e, ɨ\nк первой ступении — ɐ, ɪ, ʊ, ɨ̞\nко второй ступении — ə̝,ə, əᶷ\n\nf1 — частота первой форманты\nf2 — частота второй форманты\n\nКогда-то в домашке по визуализации в одном из дополнительных заданий надо было нарисовать такую картинку, которая отображает вокалической пространство русского языка:\n\n\n\n\n\n\n\n\n\nНо будем решать задачу постепенно.\n\n\n\n#1\n\n\nЗагрузите данные, приведите переменную phoneme к факторному типу данных.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nЧтобы модели не были чрезмерно сложны, возьмем для сравнения только нередуцированные гласные и гласные первой ступени редукции. Нас будут интересовать следующие контрасты:\n\ni vs ɪ\ne vs ɪ\na vs ɐ\no vs ɐ\nu vs ʊ\n\nСоздайте матрицу кодировки для этих контрастов.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#3\n\n\nПротестируйте гипотезы о различии частотных характеристик первой форманты (f1) по заданным контрастам. Проинтерпретируйте полученные результаты.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#4\n\n\nПротестируйте гипотезы о различии частотных характеристик второй форманты (f2) по заданным контрастам. Проинтерпретируйте полученные результаты.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nВизуализируйте полученные результаты. Постройте график, представленный ниже.\n\n\n\n\n\n\n\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW10 // Дисперсионный анализ. Ковариационный анализ"
    ]
  },
  {
    "objectID": "hw11.html",
    "href": "hw11.html",
    "title": "HW11 // Логистическая регрессия. Пуассоновская регрессия",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW11 // Логистическая регрессия. Пуассоновская регрессия"
    ]
  },
  {
    "objectID": "hw11.html#hw11_main",
    "href": "hw11.html#hw11_main",
    "title": "HW11 // Логистическая регрессия. Пуассоновская регрессия",
    "section": "",
    "text": "#1\n\n\n\nЗагрузите датасет в переменую heart. Изучите их структуру.\nПредобработайте данные, если это необходимо: удалите пропущенные значения, скорректируйте типы переменных. Перезапишите датасет.\n\n\n\n\nВ качестве ответа для самопроверки введите количество строк в датасете, полученном после удаления пропущенных значений.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nУдалить все пропущенные значения можно с помощью функции drop_na().\n\n\n\n\n#2\n\n\nСегодня мы поработаем с изученной моделью в более «машиннообученском». подходе. Начнем в разбиения выборки на обучающую (тренировочную) и тестовую.\nРазбейте данные на обучающую и тестовую выборки в соотношении 7/3 — 70% данных должно оказать в обучающей и 30% в тестовой. Сохраните обучающий датасет в переменную heart_train, а тестовый — в heart_test.\nДля воспроизводимых результатов используйте set.seed(616).\n\n\n\nВ качестве ответа для самопроверки введите среднее по переменной TenYearCHD обучающей выборки. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nЧтобы разбить датасет на тренировочную и тестовую части, необходимо:\n\nсгенерировать вектор случайных индексов из номеров строк общего датасета длиной, равной 70% от числа строк датасета\nс помощью индексации (или функции из tidyverse) вытащить строки со сгенерированными номерами и сохранить результат в heart_train\nс помощью «отрицательной» индексации (или функции из tidyverse) вытащить строки со всеми номерами, кроме сгенерированных, и сохранить результат в heart_test\n\n\n\n\n\n#3\n\n\n\nПостройте модель на обучающей выборке. Целевой переменной выступит TenYearCHD, все остальные — в качестве предикторов. Так как в модели достаточно много предикторов, взаимодействия мы включать не будем.\nПротестируйте общую статистическую значимость модели с помощью теста отношения правдоподобий. Проинтерпретируйте результаты.\n\n\n\n\nВ качестве ответа для самопроверки введите значение девиансы построенной модели (deviance), округленное до целого.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nЧтобы проестировать гипотезу об общей статистической значимости модели, необходимо:\n\nпостроить нулевую модель, аналогичную заданной, но только с одним предиктором — интерсептом\nпровести тест отношения правдоподобий с помощью функции anova(), указав в аргументе test необходимый тест\nзначение аргумента test соответствует распределению, которому подчиняется распределение значения отношения правдоподобий\n\n\n\n\n\n#4\n\n\n\nИспользуя тесты отношения превдоподобий, упростите модель, исключив незначимые предикторы.\nСравните с помощью статистического теста и информационных критериев исходную и упрощенную модели.\nВыберите, с какой в дальнейшем вы будете работать:\n\nесли модели различаются, то мы, исключив предикторы, потеряли что-то важное, значит необходимо работать с полной моделью\nесли модели не различаются, то мы, исключив предикторы, не потеряли ничего важного, значит проще работать с сокращенной моделью\n\n\n\n\n\nВ качестве ответа для самопроверки введите значение девиансы сокращенной модели (deviance), округленное до целого.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\n\nПостройте confusion matrix по тренировочным данным для выбранной в предыдущем задании модели.\n\nТак как мы работаем с медицинскими данными, воспользуемся достаточно либеральным порогом для получения категориальных предсказаний в 0.6. Идея исходит из подхода гипердиагностики — лучше взять и обследовать пациента с меньшим риском, чтобы выявить потенциально опасные патологии на раннем этапе.\n\nРассчитайте метрики предказательной силы модели — accuracy, precision, recall, F1-меру — по построенной confusion matrix.\nДайте оценку качеству модели по полученным значениям.\n\n\n\n\nДля самопроверки в поле ниже введите значение F1-меры, округленное до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nConfusion matrix имеет следующую структуру:\n\n\n\n\nПредсказания: \\(0\\)\nПредсказания: \\(1\\)\n\n\n\n\nДанные: \\(0\\)\n\\(\\text{TN}\\)\n\\(\\text{FP}\\)\n\n\nДанные: \\(1\\)\n\\(\\text{FN}\\)\n\\(\\text{TP}\\)\n\n\n\n\nTrue Positive (\\(\\text{TP}\\)) — верное предсказанные единицы\nTrue Negative (\\(\\text{TN}\\)) — верно предсказанные нули\nFalse Positive (\\(\\text{FP}\\)) — ложноположительные предсказания, ошибочно предсказанные единицы\nFalse Negative ($ — ложноотрицательные предсказания, ошибочно предсказанные нули\n\nФормулы для расчета метрик таковы:\n\\[\n\\begin{split}\n& \\text{accuracy} = \\frac{\\text{TP} + \\text{TN}}{\\text{TP} + \\text{TN} + \\text{FP} + \\text{FN}} \\\\\n& \\text{precision} = \\frac{\\text{TP}}{\\text{TP} + \\text{FP}} \\\\\n& \\text{recall} = \\frac{\\text{TP}}{\\text{TP} + \\text{FN}} \\\\\n& \\text{F1} = 2 \\cdot \\frac{\\text{precision} \\cdot \\text{recall}}{\\text{precision} + \\text{recall}}\n\\end{split}\n\\]\n\n\n\n\n#6\n\n\n\nВозьмите несколько более строгих значений порогов — 0.7, 0.8 и 0.9 — и посмотрите, справляется ли модель с предсказаниями лучше, если использовать их.\nВыберите, при каком пороге модель наиболее хорошо описывает данные. Сравнивая модели, неободимо посмотреть на все метрики, однако для принятия окончательного решения можно воспользоваться F1-мерой, как обобщенным показателем precision и recall.\n\nВозможно, проще будет сначала сделать задание 10. Это сократит код.\n\n\n\nДля самопроверки в поле ответа введите порог, при котором получаются наилучшие предсказания. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#7\n\n\nС помощью имеющейся модели и выбранного порога получите предсказания для тестовых данных.\n\n\n\nДля самопроверки в поле ответа введите среднее по вектору предсказаний, округленное до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЧтобы получить предсказания для тестовых данных, воспользуйтесь функцией predict(), в которую необходимо передать модель и новые данные, а также указать в аргументе type значение \"response\", чтобы получить предсказания вероятностей.\nДалее, используя выбранный порог, получите дискретные предсказания модели.\n\n\n\n\n\n#8\n\n\n\nПостройте confusion matrix для предсказаний на тестовой выборке и рассчитайте метрики предсказательной силы.\nСопоставьте результаты с метриками, полученными на тренировочных данных.\n\n\n\n\nДля самопроверки в поле ниже введите значение F1-меры, округленное до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nПри сопоставлении метрик необходимо понять, выше или ниже они получились на тестовой выборке по сравнению с обучающей (тренировочной).\n\nЕсли они ниже, то проблем с переобучением модели не возникло — можно пытаться экстраполировать результаты на генеральную совокупность.\nЕсли они выше, то результаты моделирования зависят больше от данных, чем от самой модели — есть трудности с обобщением результатов на генеральную сопокупность.\n\n\n\n\n\n\n#9\n\n\nПроверьте основные допущения рассматриваемой модели — линейность связи между предикторами и целевой переменной и отсутствие сверхдисперсии. Проинтерпретируйте полученные результаты.\nДля проверки линейности достаточно графической диагностики, для проверси сверхдисперсии используйте функцию ниже (она же использовалась на практике):\n\n# https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#testing-for-overdispersioncomputing-overdispersion-factor\noverdisp_fun &lt;- function(model) {\n  rdf &lt;- df.residual(model)\n  if (inherits(model, 'negbin'))\n    rdf &lt;- rdf - 1\n  rp &lt;- residuals(model, type = 'pearson')\n  Pearson.chisq &lt;- sum(rp ^ 2)\n  prat &lt;- Pearson.chisq / rdf\n  pval &lt;-\n    pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)\n  c(\n    chisq = Pearson.chisq,\n    ratio = prat,\n    rdf = rdf,\n    p = pval\n  )\n}\n\n\n\n\nДля самопроверки в поле ниже введите значение ratio, полученное при проверке допущения об отсутствии сверхдисперсии, округленное до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля проверки линейности связи необходимо построить график зависимости пирсоновских остатков от предсказанных моделью значений.\n\nПредсказания получаются из модели с помощью функции predict() с указанием type = \"response\" без использования новых данных, так как нас интересуют значения предсказания для данных, на которых модель была подобрана.\nОстатки получаются аналогично с помощью функции resid() с указанием type = \"pearson\", чтобы получить стандартизированные значения остатков.\nДля отображения тренда используется geom_smooth() с методом \"loess\", так как линейный тренд здесь не работает из-за использования функции связи внутри модели.\n\nПри проверке сверхдисперсии нулевая гипотеза теста гласит, что в данных не наблюдается сверхдисперсии, а альтернативная — что сверхдисперсия присутствует. Соответствующим образом интерпретируется и результат тестирования.\n\n\n\n\n\n#10\n\n\nНа практике упоминалось, что расчет метрик предсказательной силы модели можно обернуть в функцию, чтобы не таскать много строк кода каждый раз, когда необходимо проверить качество модели. Давайте это сделаем.\nНапишите функцию prediction_metrics(), которая будет рассчитывать метрики предсказательной силы модели на основе значений целевой переменной из данных и предсказанных вероятностей. Функция должна:\n\nпринимать на вход:\n\nвектор значений бинарной переменной из данных (data)\nвектор предсказанных моделью вероятностей (response)\nпорог, использующийся для перевода непрерывных предсказаний в дискретные (threshold)\n\nвозвращать:\n\nименованный вектор со значениями accuracy, precision, recall и F1-меры.\n\n\nПример работы функции на полной модели представлен ниже.\n\n\nprediction_metrics(data = heart_train$TenYearCHD,\n                   response = predict(model1, type = \"response\"),\n                   threshold = 0.6)\n\n  accuracy  precision     recall         F1 \n0.84946646 0.92857143 0.03194103 0.06175772 \n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЧтобы написать функцию, необходимо взять код, используемый для расчета метрика предсказательной силы модели и заменить используемые в нем переменные на соответствующие аргументы функции.\nЧтобы создать именованный вектор, нужно задать соответствие между именем элемента вектора и его значением: c(name1 = value1, name2 = value2, ...).",
    "crumbs": [
      "HW11 // Логистическая регрессия. Пуассоновская регрессия"
    ]
  },
  {
    "objectID": "hw12.html",
    "href": "hw12.html",
    "title": "HW12 // Обобщенные аддитивные модели. Регуляризованная регрессия",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW12 // Обобщенные аддитивные модели. Регуляризованная регрессия"
    ]
  },
  {
    "objectID": "hw12.html#hw12_main",
    "href": "hw12.html#hw12_main",
    "title": "HW12 // Обобщенные аддитивные модели. Регуляризованная регрессия",
    "section": "",
    "text": "PISA\n\n\n\nСегодня мы возьмем данные, полученные в ходе программы PISA (Programme for International Student Assessment, 2006), дополненные рядом показателей из данных ООН. Переменные, которые нас будут интересовать:\n\nOverall Science Score (average score for 15 year olds)\nInterest in science\nIdentifying scientific Issues\nExplaining phenomena scientifically\nSupport for scientific inquiry\nIncome Index\nHealth Index\nEducation Index\nHuman Development Index (HDI, composed of the Income index, Health Index, and Education Index)\n\nТакже в данных есть переменная Country. Так как у нас усредненные показатели по странам, то эта переменная выступает в данном случае в качестве ID (идентификатора наблюдения), поэтому её мы не будем использовать в моделировании.\nВ качестве целевой переменной нас будет интересовать Overall, остальные мы будм рассматривать как предикторы.\n\n\n\n#1\n\n\n\nУже классически, загрузите данные и проверьте их структуру.\nЕсли в данных есть пропущенные значения, удалите наблюдения, которые их содержат.\nВизуализируйте взаимосвязи между переменными датасета (за исключением Country). Что можно сказать о характере связей между переменными?\n\nДля визуализации в данном случае хорошо подойдет функция ggpairs() из пакета GGally.\n\n\n\nВ качестве ответа для самопроверки введите число строк в датасете после удаления пропущенных значений.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЧтобы удалить строки с пропущенными значениями, воспользуйтей функцией drop_na().\nФункция ggpairs() ожидает на вход датасет, состоящий только из тех переменных, взаимосвязи между которыми нас интересуют.\n\n\n\n\n\n#2\n\n\n\nПостройте обобщенную аддитивную модель gam1, в которой целевой переменной будет Overall, а нелинейными предикторами — Interest, Support, Income и Health.\nПротестируйте гипотезу о статистической значимости модели в целом.\n\n\n\n\nВ качестве ответа для самопроверки введите абсолютное значение девиансы модели (колонка Deviance из результатов тестирования значимости модели), округленное до целого.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nВ GAM-модель нелинейный предикторы вводятся внутри сплайнов (функция s()).\nКаждый нелинейный предиктор вводится внутри своего сплайна — s(pred1) + s(pred2) + s(pred3)\nТестирование гипотезы о значимости модели в целом проводится аналогично обобщенным линейным моделям — потребуется нулевая модель, содержащая в качестве предиктора только интерсепт.\nДля сравнения построенной и нулевой модели используется функция anova() с аргументом test = \"Chisq\".\n\n\n\n\n\n#3\n\n\n\nПротестируйте гипотезы о том, что связи между предикторами и целевой переменной построенной модели нелинейные.\nЕсли\n\nрезультаты тестирования гипотез показывают, что связи между всеми предикторами модели и целевой переменной нелинейные, переходите к следующему заданию\nрезультаты тестирования гипотез показывают, что в модели есть предикторы, линейно связанные с целевой переменной, то модифицируйте модель так, чтобы нелинейные предикторы были включены в модель внутри сплайнов, а линейные — вне сплайнов.\n\nсохраните результат модификации в объект gam2\nсравните с помощью статистического теста исходную и модифицированную модель\nпроверьте, изменились ли результаты тестов на нелинейность связи после модификации модели\n\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nГипотезы о (не)линейности связей между предикторами и целевой переменной тестируются автоматически при выводе статистик модели с помощью функции summary().\nGAM-модели позволяют вводить как нелинейные, так и линейные предикторы в одну и ту же модель. Общий синтаксис выглядит так (DV — целевая переменная, IV1 и IV2 — нелинейные предикторы, IV3 и IV4 — линейные предикторы):\n\n\ngam(DV ~ s(IV1) + s(IV2) + IV3 + IV4, data = ds)\n\n\nСравнить модели друг с другом позволяет функция anova(..., test = \"Chisq\"), как и в случае с GLM.\n\n\n\n\n\n\n\n\n\nЕсли в предыдущем задании не потребовалась модификация модели, то обобщенная аддитивная модель, с которой необходимо работать далее — это gam1. Если модификации была проведена, то обобщенная линейная модель, с которой необходимо работать далее — это gam2.\n\n\n\n\n\n#4\n\n\n\nПостройте модель множественной линейной регрессии , в которую включены те же предикторы, что и в обобщенную аддитивную модель. Сравните результаты тестирования статистических гипотез для обобщенной аддитивной модели и модели множественной линейной регресси.\nРассчитайте метрики MAPE и RMSE для обобщенной аддитивной модели и модели множественной линейной регрессии. На основании их значений сделайте вывод о том, какая из моделей лучше описывает закономерности, имеющиеся в данных.\n\n\n\n\nВ качестве ответа для самопроверки введите значение RMSE обобщенной аддитивной модели, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nВ модели множественной линейной регресии, исходя из её математической формулировки, все предикторы считаются линейными.\nПолучить значения метрик качества можно с помощью соответствующих функций из пакета Metrics.\n\nФункции ожидают в качестве первого аргумента реальные значения целевой переменной из данных, в качестве второго — модельные значения.\n\nМодельные значения храняться в элементе fitted.values объекта, содержащего модель — общую линейную или обощенную аддитивную.\n\n\n\n\n\n#5\n\n\nПроведите графическую диагностику обобщенной аддитивной модели. Сделайты вывод о её качестве.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля графической диагностики обобщенных аддитивных моделей используется функция gam.check().\nНеобходимо обратить внимание на распределение остатков и на зависимость остатков от предсказанных моделью значений.\n\n\n\n\n\n#6\n\n\nПроверьте выполнение допущения о concurvity. Сделайте вывод о наличии или отсутствии зависимости между предикторами.\n\n\n\n\n\n\n\nИнтерпретация значений concurvity\n\n\n\nНа практике у препода произошло помутнение сознания и он нагло наврал о том, как интерпретируются значения concurvity.\nЗначения concurvity (любой из трёх метрик) варьируются от 0 до 1.\n\nЕсли значение близко к нулю, что проблемы concurvity нет, предикторы независимы друг от друга.\nЕсли значение близко к единице, что проблема concurvity есть, один предиктор может быть выражен через другой с помощью какой-либо функции.\n\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля проверки наличия или отсутствия concurvity, используется функция concurvity(), которая в качестве аргумента принимает обобщенную аддитивную модель.\nДля интерпретации чаще всего используются значения worst и/или observed.\n\n\n\n\n\n#7\n\n\nНеким заказчиком нам велено изучить зависимость Overall от Issues, Explain, Evidence и HDI. Мы уже строили графики, по которым можно заподозрить нечто неладное относительно этих переменных, однако давайте для большей наглядности построим корреляционную матрицу между всеми этими переменными — Overall, Issues, Explain, Evidence и HDI. Сделайте вывод о том, можно ли моделировать зависимости в помощью линейных моделей и как это корректнее сделать.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#8\n\n\nСмоделируйте зависимость Overall от предикторов Issues, Explain, Evidence и HDI с помощью LASSO-регрессии.\n\nСоздайте вектор Y, содержащий значения целевой переменной, и матрицу X со значениями предикторов.\nПостройте модель LASSO-регрессии и выведите значения коэффициентов при минимальном значении штрафного коэффициента.\nЕсть ли в модели предикторы, коэффициенты при которых были обнулены в ходе регуляризации?\n\n\n\n\nВ качестве ответа для самопроверки в поле ниже введите через запятую названия предикторов, коэффициенты при которых были обнулены в ходе регуляризации. Если таких предикторов не было, введите нет. Проверка игнорирует все пробелы, но чувствительна к регистру.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nИзвлечь вектор значений целевой переменной можно через индексацию колонки с помощью оператора $ или с помощью функции pull() из tidyverse.\nПреобразовать тиббл со значениями предикторов в матрицу можно с помощью функции as.matrix().\nМодель регуляризованной регрессии строится с помощью функции cv.glmnet().\nВид регуляризации задается через аргумент alpha: 0 — ridge-регрессия, 1 — LASSO-регрессия.\nВывести значения коэффициентов модели поможет функция coef(), а её аргумент s позволит задать значения штрафного коэффициента — \"lambda.min\" или \"lambda.1se\".\n\n\n\n\n\n#9\n\n\nСмоделируйте зависимость Overall от Issues, Explain, Evidence и HDI с помощью Ridge-регрессии, оставив только те предикторы, коэффициенты при которых сохранили ненулевое значения в предыдущем задании.\n\nТе предикторы, коэффициенты при которых обнулились в LASSO-регрессии не должны быть включены в модель Ridge-регрессии.\nЕсли ни один из коэффициентов не был обнулён, то в модель включаются все предикторы.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЕсли какие-либо коэффициент в LASSO-регрессии получили нулевые значения коэффициентов, то их необходимо исключить из матрицы предикторов.\n\nМожно создать новую матрицу из исходного датасета аналогично тому, как создавалась матрица X в задании 8a, а можно с помощью индексации убрать колонки из уже созданной матрицы X.\nНовую матрицу предиктороров нужно передать в функцию cv.glmnet() с указанием аргумента alpha = 0, чтобы была построена именно ridge-регрессия.\n\n\n\n\n\n\n#10\n\n\n\nПостройте модель множественной линейной регресии (без взаимодействия), соответствующую по структуре модели ridge-регрессии из предыдущего задания.\nРассчитайте метрики качества модели MAPE и RMSE для построенной модели множественной линейной регрессии и регуляризованной регресии (ridge-регрессии) с минимальным значением штрафного коэффициента. Какая из моделей лучше описывает закономерность данных? С чем это может быть связано?\n\n\n\n\nВ качестве ответа для самопроверки в поле ниже введите значение RMSE для модели ridge-регресии, округленное до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля расчета метрик подойдут функции из пакета Metrics.\nЗначения, предсказанные общей линейной моделью можно получить, вытащив элемент fitted.values из объекта, содержащего модель.\nДля получения предсказаний регуляризованной модели необходимо воспользоваться функцией predict().\n\nТак как коэффициенты этой модели зависят от значения штрафного коэффициента — а значит и предсказанные значения также будут зависеть от его значения — в функцию predict() через аргумент s необходимо указать значения штрафного коэффициента, которое будет использовано для вычисления модельных значений. По заданию это будет s = \"lambda.min\".",
    "crumbs": [
      "HW12 // Обобщенные аддитивные модели. Регуляризованная регрессия"
    ]
  },
  {
    "objectID": "hw13.html",
    "href": "hw13.html",
    "title": "HW13 // Смешанные линейные модели",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW13 // Смешанные линейные модели"
    ]
  },
  {
    "objectID": "hw13.html#hw13_main",
    "href": "hw13.html#hw13_main",
    "title": "HW13 // Смешанные линейные модели",
    "section": "",
    "text": "Данные\n\n\n\nСегодня мы работаем с датасетом про ноутбуки, который содержит следующие переменные:\n\nCompany — компания-производитель компьютера\nProduct — бренд и модель\nTypeName — тип ноутбука (Notebook, Ultrabook, Gaming, etc.)\nInches — размер экрана\nScreenResolution — разрешение экрана\nCpu — характеристики процессора\nRam — размер оперативной памяти\nMemory — память жёсткого диска\nGPU — характеристики графического процессора\nOpSys — операционная система\nWeight — вес компьютера\nPrice_euros — цена в Евро\n\n\n\n\n#1\n\n\nЗагрузите датасет. Проверьте типы переменных. Если есть такие переменные, которые по своему содержанию должны быть другого типа, приведите их к нужному типу. Сделайте необходимые преобразования с переменными, если они потребуются.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nОбратите внимание, как записаны переменные Ram и Weight. Возможно, понадобится функция str_remove().\n\n\n\n\n#2\n\n\nМы хотим узнать, от каких технических характеристик зависит цена ноутбука. Исследуйте взаимосвязи между ценой и характеристиками ноутбуков. Предположите, какие из характеристик могут быть включены в регрессионную модель в качестве предикторов цены.\nПодойдут любые способы изучения закономерностей по типу расчета описательных статистик или визуализаций.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#3\n\n\nПостройте линейную модель model1 со случайным интерсептом, которая позволит ответить на вопрос, как зависит цена компьютера от размера экрана. В качестве случайного эффекта включите в модель группировку по компании-производителю.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля построения смешанной модели используйте функцию lmer() из пакета lme4 или lmerTest.\nФиксированные факторы вводятся в модель аналогично общим линейным моделям.\nСлучайные факторы вводятся модель с помощью синтаксиса (1 + slope|rand), где 1 — указание на случайный интерсепт, slope — переменная, задающая случайный угловой коэффициент, rand — группирующая переменная, задающая случайный фактор.\n\n\n\n\n\n#4\n\n\nПроверьте статистическую значимость модели model1 в целом и статистистическую значимость фиксированных предикторов. Проинтерпретируйте полученные результаты.\n\n\n\nДля самопроверки в поле ниже введите значение коэффициента при предикторе, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля тестирования гипотез о статистической значимости модели в целом необходима нулевая модель, в которой предиктором является только интерсепт, с такой же структурой случайных эффектов, как и в тестируемой модели.\nДля тестирования значимости фиксированных факторов используются t-тесты Вальда или тесты отношения правдоподобий.\nЛучше проверить статистическую значимость с помощью обоих тестов, чтобы иметь возможность в случае сомнений в точности тестов сопоставить их результаты.\n\n\n\n\n\n#5\n\n\nВключите в модель model1 в качестве еще одного фиксированного количественного предиктора размер оперативной памяти ноутбука (Ram) — создайте новую модель model2.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#6\n\n\nСравните две имеющиеся модели — с одним (model1) и двумя (model2) фиксированными предикторами. Проинтерпретируйте результаты.\n\n\n\nДля самопроверки введите значение статистики использованного теста, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nОбратите внимание на способ подбора моделей — так как модели различаются структурой фиксированной части, нас интересуют точные оценки их коэффициентов.\n\n\n\n\n#7\n\n\nПротестируйте статистическую значимость предикторов модели с двумя фиксированными предикторами (model2). Проинтерпретируйте результаты. Сравните с результатами тестирования значимости предикторов модели с одним фиксированным предиктором.\nПочему так могло произойти?\n\n\n\nДля самопроверки в поле ниже введите значение коэффициента при предикторе Inches, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nПри сопоставлении результатов тестирования гипотез двух моделей обратите внимание (1) на статистическую значимость и (2) на значение коэффициентов при предикторах.\n\n\n\n\n#8\n\n\n\nУсложните случайную часть модели. Возьмите за основу имеющуюся модель с двумя фиксированными предикторами и добавьте ещё один случайный интерсепт по переменной TypeName. Создайте модель model3.\nПротестируйте статистическую значимость фиксированных предикторов. Проинтерпретируйте результаты. Если есть что-либо необычное в результатах тестирования, дайте комментарий, почему это могло произойти.\n\n\n\n\nДля самопроверки в поле ниже введите значение коэффициента при предикторе Inches, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nСинтаксис модели с двумя случайными интерсептами выглядит следующим образом:\n\n\nmodel &lt;- lmer(DV ~ IV1 + IV2 + (1|rand1) + (1|rand2), data = data)\n\n\nПри сопоставлении результатов тестирования гипотез двух моделей обратите внимание (1) на статистическую значимость и (2) на значение коэффициентов при предикторах.\n\n\n\n\n\n#9\n\n\nСравните модели с двумя фиксированными предикторами друг с другом (model2 и model3). Проинтерпретируйте результаты.\n\n\n\nДля самопроверки введите значение статистики использованного теста, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nОбратите внимание на способ подбора моделей — так как у моделей одинаковая фиксированная часть, нас интересует тестирование гипотез о случайной части модели.\n\n\n\n\n#10\n\n\nПроведите диагностику модели model3. Сделайте заключение о качестве модели на основе результатов диагностики.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nТак как в модели в качестве фиксированных эффектов включены только количественные предикторы, при изучении распределения остатков достаточно посмотреть из зависимость от предсказанных значений.\nОднако в модель включены два случайных эффекта — поэтому полезно будет рассмотреть зависимость распределения остатков от каждого из них.",
    "crumbs": [
      "HW13 // Смешанные линейные модели"
    ]
  },
  {
    "objectID": "hw14.html",
    "href": "hw14.html",
    "title": "HW14 // Кластерный анализ",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW14 // Кластерный анализ"
    ]
  },
  {
    "objectID": "hw14.html#hw14_main",
    "href": "hw14.html#hw14_main",
    "title": "HW14 // Кластерный анализ",
    "section": "",
    "text": "#1\n\n\n\nЗагрузите данные. Проверьте их структуру, при необходимости скорректируйте типы переменных. Если в данных есть пропущенные значения, удалите строки, которые их содержат.\nДля упрощения дальнейшей работы отберите переменные, сродержащие ответы сотрудников на вопросы анкеты в отдельный датасет.\n\n\n\n\nДля самопроверки в поле ниже введите количество пропущенных значений, которое содержится в данных.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nКластеризуйте сотрудников по ответам на вопросы анкеты помощью алгоритма иерархической кластеризации.\nТак как результаты кластеризации существенно могут зависеть от выбранной метрики расстояния между кластерами, рассмотрите три варианта — среднее невзвешенное расстояние, метод дальнейго соседа и метод ближайшего соседа.\nВ качестве метрики расстояния между наблюдениями выберите ту, которая соответствует шкале ответов на вопросы.\nПроверьте с помощью построения дендрограмм, выявляется ли кластеризация в данных.\n\n\n\nДля самопроверки введите значение аргумента method функции иерархического кластерного анализа, при котором получается однозначная кластеризация. Если однозначная кластеризация получается при все методах расчета расстояния, введите в поле ответа all, если ни в одном методе нет однозначной кластеризации, введите none.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nИерархическая кластеризация выполняется с помощью функции hclust()\nФункция требует на вход матрицу расстояний между объектами и метод, с помощью которого рассчитается расстояние между кластерами.\nМатрицу расстояний можно получить с помощью функции dist().\nСреднее невзвешенное расстояние задается через значение \"average\" аргумента method. Метод ближайшего и дальнего соседа — значениями single и complete соответственно.\nДендрограмму можно построить, передав объект с результатами кластеризации в функцию plot().\n\n\n\n\n\n#3\n\n\nРассмотрите возможность кластеризации сотрудников по ответам на вопросы анкеты с помощью метода k-средних.\nДля начала определите оптимальное число кластеров, используя в качестве метрики качества кластеризации среднюю ширину силуэта кластера.\nИспользуйте соответствующий график для определения оптимального числа кластеров.\n\n\n\nДля самопроверки в поле ответа введите оптимальное число кластеров согласно средней ширине силуэта кластеров.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nПостроить необходимую визуализацию можно с помощью функции fviz_nbclust() из пакета factoextra.\nФункция требует на вход\n\nдатасет (x)\nметрику качества кластеризации (method, в данном случае необходимо передать в него значение \"silhouette\")\nфункцию кластеризации (FUNcluster)\nматрицу расстояний (diss)\nмаксимальное число кластеров, которое вы хотите рассмотреть (k.max)\n\nМаксимальное количество кластеров необходимо выбрать достаточно большим — например, порядка 20.\nОптимальным количеством кластеров считается то, при корой значение метрики качества кластеризации наибольшее.\n\n\n\n\n\n#4\n\n\n\nИспользуя матрицу расстояний, выполните кластеризацию методом k-средних, задав в качестве входного параметра алгоритма оптимальное количества кластеров, полученное в предыдущем задании.\nВизуализируйте кластеры. По построенной визуализации оцените результаты кластеризации.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nКластеризация методом k-средних выполняется с помощью функции k-means().\nВходными параметрами функции являются матрица расстояний (x) и количество искомых кластеров (centers).\nВиузализировать кластеры поможет функция fviz_cluster() из пакета factoextra.\n\n\n\n\n\n#5\n\n\nВизуализируйте силуэты кластеров. Оцените качество кластеризации.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДля визуализации силуэтов кластеров используйте функцию fviz_silhouette() из пакета factoextra.\nНа вход ей необходимо передать результат работы функции silhuoette() из пакета cluster.\nФункция silhuoette() ожидает на вход матрицу расстояний (dist) и вектор со значениями приписанных наблюдениям кластеров (x).\n\n\n\n\n\n#6\n\n\nРассмотрите вариант кластеризации методом k-средних с тремя кластерами. Выполните кластеризацию, визуализируйте кластеры и их силуэты.\nСравните результаты кластеризации на два и на три кластера.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#7\n\n\nРассмотрите возможность нечеткой кластеризации на имеющихся данных.\nОпределите оптимальное число кластеров, используя в качестве метрики качества кластеризации среднюю ширину силуэта кластера. В качестве степени нечеткости кластеризации (fuzziness parameter) используйте значение 1.5.\nИспользуйте соответствующий график для определения оптимального числа кластеров.\n\n\n\nДля самопроверки в поле ответа введите оптимальное число кластеров согласно средней ширине силуэта кластеров.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nПостроить необходимую визуализацию можно с помощью функции fviz_nbclust() из пакета factoextra.\nФункция требует на вход\n\nдатасет (x)\nметрику качества кластеризации (method, в данном случае необходимо передать в него значение \"silhouette\")\nфункцию кластеризации (FUNcluster, в данном случае необходимо передать в него значение fanny)\nматрицу расстояний (diss)\nмаксимальное число кластеров, которое вы хотите рассмотреть (k.max)\nfuzziness parameter, или степень нечеткости кластеров (memb.exp)\n\nМаксимальное количество кластеров необходимо выбрать достаточно большим — например, порядка 20.\nОптимальным количеством кластеров считается то, при корой значение метрики качества кластеризации наибольшее.\n\n\n\n\n\n#8\n\n\n\nИспользуя матрицу расстояний, выполните нечеткую кластеризацию методом С-средних, задав в качестве входного параметра алгоритма оптимальное количества кластеров, полученное в предыдущем задании. В качестве степени нечеткости кластеризации (fuzziness parameter) используйте значение 1.5.\nВизуализируйте кластеры и их силуэты. По построенным визуализациям оцените результаты кластеризации.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nКластеризация методом С-средних выполняется с помощью функции fanny() из пакета cluster.\nВходными параметрами функции являются матрица расстояний (x), количество искомых кластеров (k) и степень нечеткости кластеров (fuzziness parameter, memb.exp).\nВиузализировать кластеры поможет функция fviz_cluster() из пакета factoextra.\nВиузализировать силуэты кластеров помогут функции fviz_silhouette() из пакета factoextra и silhouette() из пакета cluster.\n\n\n\n\n\n#9\n\n\n\nДобавьте к датасету только с вопросами анкеты (полученному в задании 1.b) переменную, содержащую степень принадлежности наблюдений к большему кластеру. Сохраните результат в новый объект, чтобы не было перезаписи исходного датасета.\nПостройте линейную модель, в которой целевой переменной будет степень принадлежности наблюдений к большему кластеру, а предикторами — ответы на вопросы анкеты.\n\n\n\n\nДля самопроверки в поле ниже введите значение скорректированного коэффициента детерминации построенной модели, округленное до сотых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nДобавить переменную в датасет можно с помощью функции mutate().\nЗначения степени принадлежности наблюдений к каждому из кластеров содержаться в элементе membership объекта с результатами нечеткой крастеризации.\nЭлемент membership представляет собой матрицу, в которой первая колонка — степень принадлжености к первому кластеру, вторая — ко второму и так далее.\n\n\n\n\n\n#10\n\n\n\nЗагрузите датасет с формулировками вопросов анкеты.\nСоздайте датасет, в котором будут содержаться статистики статистически значимых коэффициентов построенной линейной модели и соответствующие им вопросы. Схема датасета представлена ниже.\n\n\n\n\nEstimate\nStandard Error\nt\np\nQuestion\nIndic\n\n\n\n\n0.02\n0.003\n4.40\n0.04\nq_011\nТекст вопроса\n\n\n…\n…\n…\n…\n…\n…\n\n\n\n\nОпираясь на формулировки статистически значимых вопросов, предложите интерпретацию кластеризации: какие сотрудники оказались в рассматриваемом (большем) кластере?\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nЧтобы получить требуемый датасет, необходимы выполнить следующие шаги:\n\nИзвлечить из аутпута функции summary() таблицу со статистиками коэффициентов (coeffisients) через индксацию списка по имени элемента.\nПреобразовать её в тиббл с помощью функции as_tibble().\n\nНазвания предикторов (переменных, содержащих ответы на вопрос) содержиться в названиях строк. Чтобы включить их в датасет в функции as_tibble() в аргументе rownames укажите название колонки, в которую необходимо записать названия предикторов.\nДля удобства можно перезадать имена колонок после создания тиббла с помощью функции set_names().\n\nОбъедините с помощью функции right_join() полученный тиббл с датасетом, содержащим формулировки вопросов.\nОтфильтруйте статистически значимые вопросы по колонке со значениями p-value.",
    "crumbs": [
      "HW14 // Кластерный анализ"
    ]
  },
  {
    "objectID": "hw14.html#hw14_add",
    "href": "hw14.html#hw14_add",
    "title": "HW14 // Кластерный анализ",
    "section": "Дополнительные задания",
    "text": "Дополнительные задания\n\n#1\n\n\nОтберите из исходного датасета те наблюдения, которые не попали в больший кластер по результатам нечеткой кластеризации.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#2\n\n\nПостройте матрицу расстояний на отобранных наблюдений.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#3\n\n\nРассмотрите возможность нечеткой кластеризации отобранных наблюдений.\nОпределите оптимальное число кластеров, используя в качестве метрики качества кластеризации среднюю ширину силуэта кластера. В качестве степени нечеткости кластеризации (fuzziness parameter) используйте значение 1.5.\nИспользуйте соответствующий график для определения оптимального числа кластеров.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#4\n\n\n\nИспользуя матрицу расстояний, выполните нечеткую кластеризацию методом С-средних, задав в качестве входного параметра алгоритма оптимальное количества кластеров, полученное в предыдущем задании. В качестве степени нечеткости кластеризации (fuzziness parameter) используйте значение 1.5.\nВизуализируйте кластеры и их силуэты. По построенным визуализациям оцените результаты кластеризации.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nИзучите матрицу, содержащию значения степени принадлежности наблюдений к кластерам. Сделайте вывод о наличии или отсутствии кластеризации.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW14 // Кластерный анализ"
    ]
  },
  {
    "objectID": "hw15.html",
    "href": "hw15.html",
    "title": "HW15 // Анализ главных компонент. Эксплораторный факторный анализ",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW15 // Анализ главных компонент. Эксплораторный факторный анализ"
    ]
  },
  {
    "objectID": "hw15.html#hw15_main",
    "href": "hw15.html#hw15_main",
    "title": "HW15 // Анализ главных компонент. Эксплораторный факторный анализ",
    "section": "",
    "text": "Данные\n\n\n\nСегодня мы работаем с датасетом по Большой пятерке (Big Five). Вспомнить структуру модели можно тут.\n\n\n\n\n\nДанные собирались с помощью опросника Big-Five Factor Markers. На измерение каждого фактора в опроснике отведено по десять утверждений — с этими переменными мы будем работать:\n\nEXT1–EXT10 — extraversion\nEST1–EST10 — neuroticism (emotional stability)\nAGR1–AGR10 — agreeableness\nCSN1–CSN10 — conscientiousness\nOPN1–OPN10 — openness\n\nПодробное описание датасета можно найти в этом файле.\nОригинальный датасет содержит 1 015 342 наблюдения — это очень много, возможно, не хватит оперативной памяти, поэтому мы будем работать с его частью.\n\n\n\n#1\n\n\n\nЗагрузите данные. Проверьте их структуру и типы переменных.\nПри необходимости скорректируйте типы переменных.\nЕсли в данных есть пропущенные значения или они возникли в ходе предобработки, удалите их из датасета.\n\n\n\n\nДля самопроверки в поле ниже введите количество строк в датасете, получившемся после предобработки (корректировки типов переменных и удаления пропущенных значений).\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nОбратите внимание на структуру файла с данными, в особенности на разделитель колонок, который в нем используется.\nПри предобработке данных может пригодится функция across(), которая позволяет выделить колонки, по которым необходимо провести предобработку.\nВозможно, полезно будет вспомнить регулярные выражения для отбора необходимых колонок.\n\n\n\n\n\n#2\n\n\n\nОтберите переменные для анализ — пункты опросника (EXT1–EXT10, EST1–EST10, AGR1–AGR10, CSN1–CSN10, OPN1–OPN10).\nПостройте и визуализируйте корреляционную матрицу по отобранным переменным.\n\nЕсть ли нечто странное в данных?\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nОбратите внимание на силу корреляций, а также на их направление.\nС чем это может быть связано, если мы предполагаем, что опросник хорошо сконструирован и его психометрические показали достаточно высокие?\n\n\n\n\n\n#3\n\n\nСкорректируйте странности, обнаруженные по корреляционной матрице.\nВероятно, поможет матрица направлений вопросов.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nПодойти к задаче перекодировки можно следующим образом:\n\nЗагрузить матрицу направлений вопросов\nОбъединить направления и баллы по соответствующим вопросам\nМаксимальный возможный балл по одному вопросу — 6\n\nЕсли вопрос обратный, то необходимо из 6 вычесть балл респондента\nЕсли вопрос прямой, оставить кодировку без изменений\n\nВ ходе преобразований для объединения тибблов потребуется перевести из в длинных формат, а затем итоговый датасет вновь перевести в широкий формат, чтобы функции работали на нем корректно.\n\n\n\n\n\n#4\n\n\nВыполните анализ главных компонент на имеющихся данных. Стандартизируйте переменные перед проведением анализа.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#5\n\n\nПостройте график, отображающий информативность главных компонент.\nСколько получается главных компонент, согласно критерию информативности?\n\n\n\nДля самопроверки в поле ниже введите число информативных главных компонент.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nВ качестве меры информативности главной компоненты используйте стандартное отклонение по ней.\nГлавная компонента считается неинформативной, если её дисперсии меньше дисперсии исходных переменных.\n\n\n\n\n\n#6\n\n\nПостройте график, отображающий накопленную долю объясненной главными компонентами дисперсии данных.\nСколько главных компонент достаточно для объяснения 80% дисперсии данных?\n\n\n\nДля самопроверки в поле ниже введите число главных компонент, достаточное для объяснения 80% дисперсии данных.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#7\n\n\nПроверьте с помощью критерия сферичности Бартлетта и меры Кайзер-Мейера-Олкина (КМО), насколько имеющиеся данные подходят для эксплораторного факторного анализа.\n\n\n\nДля самопроверки в поле ниже введите через запятую значение статистики критерия сферичности Бартлетта и значение меры КМО (overall), округленные до десятых. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#8\n\n\nВыясните, сколько факторов присутствует в латентной структуре данных, с помощью параллельного анализа.\n\n\n\nДля самопроверки в поле ниже введите количества факторов, выявленных с помощью параллельного анализа.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#9\n\n\nПостройте две модели ЭФА:\n\nпервая должна содержать столько факторов, сколько предполагает теоретическая модель личностных черт\nвторая должна содержать столько факторов, сколько предполагают результаты параллельного анализа\n\nСравните полученные решения с точки зрения (a) уникальностей, (б) распределения переменных по фактором (факторных нагрузок), (в) доли объясненной дисперсии.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nОжидается, что вопросы, относящиеся теоретически к одному конструкту будут иметь высокие нагрузки на один из факторов, и низкие на все остальные.\nВысокие уникальности свидетельсвуют о том, что переменная плохо объясняется факторами, то есть плохо вписываются в построенную модель.\n\n\n\n\n\n#10\n\n\nПостройте две модели КФА, в которых количества факторов соответствует теоретической модели личностных черт. В первой модели используйте метод вращения promax, во второй — oblimin.\nСравните результаты, полученные с помощью наклонных вращений с результатами, полученными в предыдущем задании с точки зрения (a) уникальностей, (б) распределения переменных по фактором (факторных нагрузок), (в) доли объясненной дисперсии.\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW15 // Анализ главных компонент. Эксплораторный факторный анализ"
    ]
  },
  {
    "objectID": "hw16.html",
    "href": "hw16.html",
    "title": "HW16 // Конфирматорный факторный анализ",
    "section": "",
    "text": "Основные задания",
    "crumbs": [
      "HW16 // Конфирматорный факторный анализ"
    ]
  },
  {
    "objectID": "hw16.html#hw16_main",
    "href": "hw16.html#hw16_main",
    "title": "HW16 // Конфирматорный факторный анализ",
    "section": "",
    "text": "Данные\n\n\n\nСегодня мы вновь работаем с датасетом по Большой пятерке (Big Five). Вспомнить структуру модели можно тут.\n\n\n\n\n\nДанные собирались с помощью опросника Big-Five Factor Markers. На измерение каждого фактора в опроснике отведено по десять утверждений — с этими переменными мы будем работать:\n\nEXT1–EXT10 — extraversion\nEST1–EST10 — neuroticism (emotional stability)\nAGR1–AGR10 — agreeableness\nCSN1–CSN10 — conscientiousness\nOPN1–OPN10 — openness\n\nПодробное описание датасета можно найти в этом файле.\nОригинальный датасет содержит 1 015 342 наблюдения — это очень много, возможно, не хватит оперативной памяти, поэтому мы будем работать с его частью.\n\n\n\n#1\n\n\n\nЗагрузите данные. Проверьте их структуру и типы переменных.\nПри необходимости скорректируйте типы переменных.\nЕсли в данных есть пропущенные значения или они возникли в ходе предобработки, удалите их из датасета.\n\n\n\n\nДля самопроверки в поле ниже введите количество пропущенных значений в датасете.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nНе ведитесь на то, что данные те же — да, это то же исследование, но данные могут быть организованы не так, как в прошлый раз.\n\n\n\n\n#2\n\n\n\nПостройте и визуализируйте корреляционную матрицу по интересующим нас переменным (пунктам опросника).\nЧто происходит в данных? Нужно ли что-либо поправить?\nПредобработайте данные, если это необходимо.\n\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказка\n\nОбратите внимание на силу корреляций, а также на их направление.\n\n\n\n\n#3\n\n\nПостройте базовую модель КФА (model1), соответствующую структуре модели Big Five.\nПри описании структуры модели для обозначения факторов используйте сокращения AGR, CSN, EST, EXT и OPN.\n\n\n\nДля самопроверки в поле ниже введите число степеней свободы модели (Degrees of freedom) из аутпута функции summary().\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nЧтобы построить модель, необходимо:\n\nзадать структуру модели в виде строки с использованием операторов =~, ~~ и + — удобнее сохранить её в какую-либо переменную\nс помощью функции cfa() из пакета lavaan построить модель, указав структуру модели и данные, на которых будут подобны её параметры\nв структуре модели Big Five есть только пять латентных переменных первого уровня (личностных черт), латентные переменные второго уровня отсутствуют\nпри отсутствии латентных переменных второго уровня корреляция между факторами первого уровня функцией cfa() по умолчанию включаются в модель\n\n\n\n\n\n#4\n\n\nРассчитайте значение метрик качества модели. Помимо основных — CFI, TLI, SRMR, RMSEA — можете выбрать любые, которые считаете необходимыми.\nСделайте вывод о качестве модели и её соответствии данным.\n\n\n\nДля самопроверки в поле ниже введите значение RMSEA, округленное до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nЗначения метрик качества модели можно получить с помощью функции fitmeasures(), во втором аргументе которой необходимо перечислить требуемые метрики в виде текстового вектора, если вы хотите сократить аутпут.\nДля оценки качества модели можете использовать стандартные пороговые значения:\n\nдля CFI и TLI — 0.95\nдля SRMR и RMSEA — 0.05\n\n\n\n\n\n\n#5\n\n\n\nПриведите результаты моделирования к стандартизированному виду.\nИзучите оценки параметров модели. Сделайте вывод о том, удалось ли обнаружить ожидаемую структуру в данных.\n\n\n\n\nДля самопроверки в модели ниже введите количество факторных нагрузок, которые оказались статистически незначимы.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\nПривести аутпут к стандартизированному виду поможет функция standardizedsolution().\nЭта функция возвращает датафрейм, с которым можно взаимодействовать как с любым датафреймом.\nДля удобства можете отдельно изучить факторные нагрузки, отдельно корреляции и отдельно — остатки модели.\n\n\n\n\n\n#6\n\n\nОкей. Давайте выдвинем предположение, что всё-таки за пятью факторами скрывается единый фактор — назовём его Personality. Хотя это не очень согласуется с тем, как была теоретически сформулирована модель, попробуем оценить, получается ли более хорошей модель с G-фактором на имеющихся данных.\nПостройте модель КФА (model2), в которой латентными переменными первого уровня будут пять личностных черт модели Big Five, а латентной переменной второго уровня — фактор Personality.\nПри описании структуры модели для обозначения факторов используйте сокращения AGR, CSN, EST, EXT, OPN и PER (для Personality).\n\n\n\nДля самопроверки в поле ниже введите число степеней свободы модели (Degrees of freedom) из аутпута функции summary().\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nЧтобы построить модель, необходимо:\n\nзадать структуру модели в виде строки с использованием операторов =~, ~~ и + — удобнее сохранить её в какую-либо переменную\nфактор второго уровня вводится в модель аналогично тому, как вводились факторы первого уровня, однако теперь в качестве «наблюдаемых» переменных выступают факторы первого уровня\nс помощью функции cfa() из пакета lavaan построить модель, указав структуру модели и данные, на которых будут подобны её параметры\nпри наличии латентных переменных второго уровня корреляция между факторами первого уровня функцией cfa() в модель не включаются\n\n\n\n\n\n#7\n\n\nСравните модели model1 и model2 друг с другом с помощью метрик качества модели.\nКакая из моделей лучше соответствует данным?\n\n\n\nДля самопроверки в поле ниже введите абсолютную разницу между значениями индекса CFI двух моделей, округленную до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#8\n\n\nИзучите индексы модификации модели. Прежде всего интересно узнать, не потеряла ли модель что-то важное, когда из неё были удалены корреляции между личностными чертами.\nВыведите индексы модификации для корреляций между факторами первого уровня. Стоит ли включить эти корреляции в модель?\n\n\n\nДля самопроверки в поле ниже введите значение наименьшего индекса модификации, округленное до тысячных. В качестве десятичного разделителя используйте точку.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\nЧтобы отобрать необходимые индексы модификации, необходимо осуществить фильтрацию датафрейма по следующим условиям:\n\nв колонках lhs и rhs должны быть разные значения\nв колонках lhs и rhs значения не должны заканчиваться на цифру\n\n\n\n\n\n#9\n\n\n\nНа основании результатов предыдущего задания скорректируйте модель model2, включив в неё те корреляции, которые могли бы существенно улучшить модель. Постройте модель model3.\nСравните три модели (model1, model2 и model3) друг с другом с помощью метрик качества модели.\n\nКакая из моделей лучше соответствует данным?\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный\n\n\n\n\n\n\n#10\n\n\nСравните три модели (model1, model2 и model3) друг с другом с помощью теста \\(\\chi^2\\).\nСтоит ли включать в модель латентную переменную второго уровня? Что важнее учесть в модели — G-factor (Personality) или корреляции между факторами (личностными чертами)?\n\n\n\nОписание формата инпута.\n\n\n\n\n\n\n\n\n\n\nПодсказки\n\n\n\nКак делать задание?\n\n\n\n\nЧто надо сделать?\n\n\n\n\nОтвет неверный",
    "crumbs": [
      "HW16 // Конфирматорный факторный анализ"
    ]
  }
]